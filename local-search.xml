<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构复习</title>
    <link href="/2023/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><strong>算法1.1</strong> 将原本有序的两个带头节点的单链表La和Lb合并成Lc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">mergeList</span><span class="hljs-params">(LinkedList La, LinkedList Lb, LinkedList &amp;Lc)</span><br>&#123;<br>Node *p = La-&gt;next, *q = Lb-&gt;next;<br>Lc = La;<br><span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br><span class="hljs-keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;<br>Lc-&gt;next = p;<br>p = p-&gt;next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Lc-&gt;next = q;<br>q = q-&gt;next;<br>&#125;<br>Lc = Lc-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span> (p) Lc-&gt;next = p;<br><span class="hljs-keyword">else</span> Lc-&gt;next = q;<br>&#125;<br></code></pre></td></tr></table></figure><p>以后再补充。</p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><ul><li><p>二叉树的性质除了一堆显而易见的，只剩下一个$n_0 &#x3D; n_2 + 1$。</p></li><li><p>满二叉树和完全二叉树：自己区分。</p></li></ul><p><strong>算法2.1</strong> 二叉树的先序中序后序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BinTree T)</span><br>&#123;<br><span class="hljs-keyword">if</span> (!T) <span class="hljs-keyword">return</span>;<br>print(T-&gt;data);<br>visit(T-&gt;lc);<br>visit(T-&gt;rc);<br>&#125;<br></code></pre></td></tr></table></figure><p>线索二叉树：若没有孩子，则lc-&gt;前驱，rc-&gt;后继。</p><p>树转二叉树：lc-&gt;长子，rc-&gt;兄弟。</p><p>森林转二叉树：先把根节点拼起来变成树，然后树转二叉树。</p><p>哈夫曼树和哈夫曼编码</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>保研复习科目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程</title>
    <link href="/2023/04/10/SoftwareEngineer/"/>
    <url>/2023/04/10/SoftwareEngineer/</url>
    
    <content type="html"><![CDATA[<p>来点传统手写笔记</p><p><img src="https://api2.mubu.com/v3/document_image/4a8098c1-88aa-48f5-87f0-c4a9fac204f4-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/b219dda4-b91c-4bec-b00b-a953d49d2952-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/381522e0-6329-4540-bcac-17396d270015-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/661c76b0-0b41-4397-8079-cd556af22dc8-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/f8583f94-f3ba-427b-aeee-b4b6cd7d50ec-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/bbb2d461-5cf1-426d-b4b2-86096b419d41-15002533.jpg"><br><img src="https://api2.mubu.com/v3/document_image/69159b4e-1c74-46d5-afc9-249e38db42a9-15002533.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统原理</title>
    <link href="/2022/09/16/DatabaseSystemConcepts/"/>
    <url>/2022/09/16/DatabaseSystemConcepts/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-Introduction"><a href="#第一章-Introduction" class="headerlink" title="第一章 Introduction"></a>第一章 Introduction</h1><h2 id="1-3-View-of-Data"><a href="#1-3-View-of-Data" class="headerlink" title="1.3 View of Data"></a>1.3 View of Data</h2><ul><li>Data Model<ul><li>对数据组织与管理&#x2F;使用方式的抽象描述，包括：<ul><li>数据组织的语法定义，如数据项、数据项间的联系</li><li>数据组织的语义定义，如完整性约束</li></ul></li><li>例子：<ul><li>Relation Model（最典型的表格）</li><li>XML</li></ul></li></ul></li><li>Levels of Abstraction<ul><li>Physical level: 描述数据<strong>实际</strong>是怎么存的，一个块多大，存在存储器的什么位置，索引。</li><li>Logic level: 描述数据的逻辑关系<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">type instructor <span class="hljs-operator">=</span> record<br>ID: string;<br>name: string;<br>dept_name: string;<br>salary: <span class="hljs-type">integer</span>;<br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure></li><li>View level: 应用层查看到的数据，可以隐藏一些细节，比如数据类型，或者出于隐私考虑隐藏<code>salary</code>字段。</li></ul></li><li>Model, Schema, Instance<ul><li>model: <code>R = &#123;&lt;a1, a2, ..., an&gt;&#125;</code></li><li>schema: <code>Instructor = &lt;ID, name, dept_name, salary&gt;</code></li><li>instance: <code>&lt;2222, Einstein, Physics, 95000&gt;</code></li></ul></li><li>Data Independence<ul><li>物理存储发生变化，调整逻辑模式到内模式的映射，保证逻辑模式不变</li><li>逻辑结构发生变化，调整外模式到逻辑模式的映射，保证外模式不变</li></ul></li></ul><h1 id="第二章-Introduction-to-Relational-Model"><a href="#第二章-Introduction-to-Relational-Model" class="headerlink" title="第二章 Introduction to Relational Model"></a>第二章 Introduction to Relational Model</h1><h2 id="2-1-Relational-Database的结构"><a href="#2-1-Relational-Database的结构" class="headerlink" title="2.1 Relational Database的结构"></a>2.1 Relational Database的结构</h2><ul><li>$R&#x3D;(A_1, A_2, \cdots, A_n)$ 是一个relation schema</li><li>其中:<ul><li>$A_1, A_2, \cdots, A_n$是attributes</li><li>$A_i$的取值范围是$D_i$，叫做domain</li></ul></li><li>例子：<code>Instructor = &lt;ID, name, dept_name, salary&gt;</code></li><li>由$R$定义的一个instance $r$写作$r(R)$</li><li>表示为一张table</li><li>每一个$r$的元素$t$被称作一个tuple，一个tuple就是表中的一行。</li><li>attribute一般要求要原子化，不可再分。<ul><li>null是每一个的attribute可选值。</li></ul></li><li>行列之间相互独立，交换不同行列之间的顺序没有任何影响</li></ul><h2 id="2-3-Keys"><a href="#2-3-Keys" class="headerlink" title="2.3 Keys"></a>2.3 Keys</h2><ul><li><strong>定义：</strong>对于给定的relation schema$R(A_1, A_2, \cdots,A_n)$，$K$是$R$的一个子集，若对于任意两个tuple$r(R)$，他们在$K$上的attribute都不完全相同，则称$K$是$R$的一个<strong>superkey</strong>。</li><li><strong>定义：candidate key</strong>是最小的$K$。</li><li>primary key（主键）是管理员人为挑选的candidate key</li><li>primary key的值不能为null</li><li>primary key的值被称为primary attribute（主属性）</li><li><strong>定义：</strong>如果一些键在r1中，且是r2的主键，则称这些键是r1参照r2的外键。</li><li>在定义具有外键的r1之前必须先定义r2。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理与技术</title>
    <link href="/2022/09/12/CompilationPrinciplesandTechniques/"/>
    <url>/2022/09/12/CompilationPrinciplesandTechniques/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-编译概述"><a href="#第一章-编译概述" class="headerlink" title="第一章 编译概述"></a>第一章 编译概述</h1><h2 id="1-1-编译和解释"><a href="#1-1-编译和解释" class="headerlink" title="1.1 编译和解释"></a>1.1 编译和解释</h2><p>翻译程序分为两类：<mark>编译器</mark>和<mark>解释器</mark></p><ul><li>编译器<ul><li>将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序</li><li>先编译，再执行</li></ul></li><li>解释器<ul><li>解释程序解释执行源程序，不生成目标程序</li><li>同时处理程序和数据</li><li>边解释，边执行</li></ul></li></ul><p>Java语言处理器：编译+解释</p><h2 id="1-2-编译的阶段和任务"><a href="#1-2-编译的阶段和任务" class="headerlink" title="1.2  编译的阶段和任务"></a>1.2  编译的阶段和任务</h2><ol><li>分析阶段：根据源语言的定义，分析源程序的结构<ol><li>词法分析<br>对构成源程序的字符串进行分解，识别出每个具有独立意义的字符串<strong>（即单词，lexeme）</strong>，将其转化为<strong>记号（token）</strong>，形成记号流。</li><li>语法分析<br>把记号流按语言的语法结构层次地分组，以形成语法短语，常用语法树表示。<br><img src="https://api2.mubu.com/v3/document_image/82c09518-f082-430e-a562-a748342fa5cc-15002533.jpg" alt="语法分析树"></li><li>语义分析<br>对语句的意义进行检查分析，确定类型。一个重要任务：<strong>类型检查</strong>。<ul><li>运算符和运算对象是否符合要求</li><li>数组下标是否合法</li><li>形参与实参的个数和类型是否匹配</li></ul></li></ol></li><li>综合阶段：根据分析结果构造出所要求的目标程序<ol><li>中间代码生成<ul><li>易于产生</li><li>易于翻译成目标代码</li><li>三地址代码：除了等号之外至多只有一个运算符；编译程序生成临时变量保存中间结果；有些三地址指令少于3个操作数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// total:=total+rate*4 的三地址代码</span><br>temp1 := inttoreal(<span class="hljs-number">4</span>)<br>temp2 := id2 * temp1<br>temp3 := id1 + temp2<br>id1 := temp3<br></code></pre></td></tr></table></figure></li></ul></li><li>代码优化<br>对中间代码进行改进，使之占用空间更少，运行更快。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 优化后的代码</span><br>temp1 := id2 * <span class="hljs-number">4.0</span><br>temp2 := id1 + temp1<br>id1 := temp2<br></code></pre></td></tr></table></figure></li><li>目标代码生成<br>生成可重定位的汇编代码或机器代码<ol><li>对程序中每个变量指定内存单元</li><li>对变量进行寄存器分配</li></ol></li></ol></li><li>符号表管理<br>在编译的各个阶段记录源程序用的标志符和他们的属性信息</li><li>错误处理<ul><li><strong>词法分析</strong>程序可以检测出非法字符错误。</li><li><strong>语法分析</strong>程序能够发现记号流不符合语法规则的错误。</li><li><strong>语义分析</strong>程序试图检测出具有正确的语法结构，但对所涉及的操作无意义的结构。</li><li><strong>代码生成</strong>程序可能发现目标程序区超出了允许范围的错误。</li><li>由于<strong>计算机容量的限制</strong>，编译程序的处理能力受到限制而引起的错误。</li><li>发现错误后，要确定错误发生的位置和性质并进行适度的恢复。</li></ul></li></ol><h1 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h1><h2 id="3-1-词法分析程序和语法分析程序之间的3种关系"><a href="#3-1-词法分析程序和语法分析程序之间的3种关系" class="headerlink" title="3.1 词法分析程序和语法分析程序之间的3种关系"></a>3.1 词法分析程序和语法分析程序之间的3种关系</h2><ol><li>词法分析作为单独的一遍<br>先对程序进行词法分析，生成中间文件存储在磁盘中，再进行语法分析</li><li>词法分析作为语法分析的子程序<br><img src="https://api2.mubu.com/v3/document_image/d54c162a-e8a1-4bf4-b67f-2dc4367196b9-15002533.jpg" alt="词法分析作为语法分析的子程序"></li><li>词法分析程序和语法分析程序作为协同程序</li></ol><ul><li>*分离词法分析程序的好处<ol><li>可以简化设计</li><li>可以改进编译程序的效率</li><li>可以加强编译程序的可移植性</li></ol></li></ul><h2 id="3-2-词法分析程序的输入与输出"><a href="#3-2-词法分析程序的输入与输出" class="headerlink" title="3.2 词法分析程序的输入与输出"></a>3.2 词法分析程序的输入与输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>在进行词法分析的时候，为了确定一个符号的意义和作用，往往需要超前扫描若干个字符，比如C语言中的<code>==</code>，<code>/*</code>，<code>++</code>等。所以就必须在词法分析程序读入源程序时设置缓冲区。<br>然而单一的缓冲区无论如何都无法避免一个单词被缓冲区的边界打断，因此设立了<strong>配对缓冲区</strong>。</p><ul><li>配对缓冲区<br>  <img src="https://api2.mubu.com/v3/document_image/2dfb1424-c3e4-4b99-a937-9a424b725697-15002533.jpg" alt="配对缓冲区"></li><li>每半区带有结束标记的缓冲区<br>  <img src="https://api2.mubu.com/v3/document_image/8353e071-074f-49d3-af1f-dbfb0f493523-15002533.jpg" alt="每半区带有结束标记的缓冲区"></li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>词法分析程序的输出是<strong>记号</strong>，记号和它的属性是一个二元组。</p><ul><li>在词法分析阶段，对记号只能确定一种属性<ul><li>标识符：单词在符号表中入口的指针</li><li>常数：它所表示的值</li><li>关键字：（一符一种、或一类一种）</li><li>运算符：（一符一种、或一类一种）</li><li>分界符：（一符一种、或一类一种）</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// total:=total+rate*4 的词法分析结果</span><br>&lt;id，指向标识符total在符号表中的入口的指针&gt;<br>&lt;assign_op，- &gt;<br>&lt;id，指向标识符total在符号表中的入口的指针&gt;<br>&lt;plus_op，- &gt;<br>&lt;id，指向标识符rate在符号表中的入口的指针&gt;<br>&lt;mul_op，- &gt;<br>&lt;num，整数值<span class="hljs-number">4</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="3-3-记号的描述和识别"><a href="#3-3-记号的描述和识别" class="headerlink" title="3.3 记号的描述和识别"></a>3.3 记号的描述和识别</h2><p>线性文法，自动机</p><h2 id="3-4-词法分析程序的设计与实现"><a href="#3-4-词法分析程序的设计与实现" class="headerlink" title="3.4 词法分析程序的设计与实现"></a>3.4 词法分析程序的设计与实现</h2><ul><li><p>步骤：</p><ol><li>给出描述该语言各种单词符号的词法规则</li><li>画出状态转换图</li><li>根据状态转换图构造词法分析器</li></ol></li><li><p>输出形式：二元式</p></li></ul><h1 id="第四章-语法分析"><a href="#第四章-语法分析" class="headerlink" title="第四章 语法分析"></a>第四章 语法分析</h1><h2 id="4-1-语法分析简介"><a href="#4-1-语法分析简介" class="headerlink" title="4.1 语法分析简介"></a>4.1 语法分析简介</h2><ul><li>输入：记号流</li><li>输出：分析树</li><li>常用的分析法：<ul><li>自顶向下</li><li>自底向上</li></ul></li><li>处理语法错误<ol><li>紧急方式恢复：直接忽略掉出错的语法结构</li><li>短语级恢复：局部纠正错误</li><li>出错产生式：扩充文法，补充出错的产生式</li><li>全局纠错：代价太大，只有理论上的意义</li></ol></li></ul><h2 id="4-2-自顶向下语法分析"><a href="#4-2-自顶向下语法分析" class="headerlink" title="4.2 自顶向下语法分析"></a>4.2 自顶向下语法分析</h2><h3 id="4-2-1-递归下降分析"><a href="#4-2-1-递归下降分析" class="headerlink" title="4.2.1 递归下降分析"></a>4.2.1 递归下降分析</h3><ul><li>试图为输入符号串创建一个最左推导序列</li><li>每次遇到一个匹配输入串的产生式，就按照这个产生式展开</li><li>效率低，代价高</li></ul><h3 id="4-2-2-递归调用预测分析"><a href="#4-2-2-递归调用预测分析" class="headerlink" title="4.2.2 递归调用预测分析"></a>4.2.2 递归调用预测分析</h3><ol><li>如何克服回溯<ul><li>根据所面临的符号流选择一个唯一的产生式</li><li>如果这个产生式可以匹配，那么最后正确匹配的结果必定用到这个产生式</li><li>如果这个产生式不能匹配，那么其他的产生式也不可能匹配</li><li>如何实现？<ul><li>让每一个产生式开头的字符各不相同</li></ul></li></ul></li><li>对文法的要求<ul><li>不含左递归</li><li><em>首符集</em>（开头的几个符号）不相交</li></ul></li><li>具体操作ppt上有，略。</li><li>这一块ppt上讲的全是方法，没有理论和概念，建议面向题目学习。关键词：消除左递归，构造转换图，化简转换图</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理与技术</tag>
      
      <tag>学校课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/09/10/OperatingSystem/"/>
    <url>/2022/09/10/OperatingSystem/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h1><h2 id="1-2-计算机系统组织"><a href="#1-2-计算机系统组织" class="headerlink" title="1.2 计算机系统组织"></a>1.2 计算机系统组织</h2><h3 id="1-2-1-计算机系统操作"><a href="#1-2-1-计算机系统操作" class="headerlink" title="1.2.1 计算机系统操作"></a>1.2.1 计算机系统操作</h3><ul><li><p>I&#x2F;O设备可以和CPU同时工作</p></li><li><p>每一类I&#x2F;O设备都有自己的控制器</p></li><li><p>每一个控制器都有一个缓冲区</p></li><li><p>CPU将数据在缓冲区和内存之间移动</p></li><li><p>I&#x2F;O操作将数据从I&#x2F;O设备移动到缓冲区</p></li><li><p>控制器通过<mark>中断</mark>告知CPU自己已经完成了I&#x2F;O操作。</p></li><li><p>中断的类型</p><ul><li>trap: trap类型的中断因<strong>软件</strong>产生，程序执行过程中出现错误（算数移除，访存越界）或用户请求时会发生此类型的中断。</li><li>interrupt: interrupt类型的中断因<strong>硬件</strong>产生。I&#x2F;O完成，计时器到时，硬件故障时会发生此类型的中断。</li></ul></li><li><p>中断发生时要：</p><ol><li>启动中断服务程序</li><li>保存现场</li><li>屏蔽其他中断</li></ol></li><li><p><strong>操作系统是由中断驱动的</strong>（换言之，操作系统从不自己主动做事情）。</p></li><li><p>处理中断</p><ol><li>CPU保存寄存器状态和程序计数器</li><li>判断发生了哪种中断</li><li>调用对应的代码段处理中断</li></ol></li><li><p>中断循环</p><ol><li>处理器在取下一条指令之前，先判断有没有中断</li><li>若没有中断，则继续取下一条指令执行当前程序</li><li>若有中断，暂停现有程序，运行中断处理程序</li></ol></li><li><p>中断时间线<br>  挺好的一张图，看懂就好<br>  <img src="https://api2.mubu.com/v3/document_image/0b9538b9-99d7-4fa9-b4ce-4e09df661a2e-15002533.jpg" alt="中断时间线"></p></li></ul><h3 id="1-2-2-存储结构"><a href="#1-2-2-存储结构" class="headerlink" title="1.2.2 存储结构"></a>1.2.2 存储结构</h3><p>计组那一套</p><ul><li>分级存储<ul><li>主存</li><li>第二存储</li><li>磁盘</li><li>磁带</li></ul></li></ul><h3 id="1-2-3-I-x2F-O结构"><a href="#1-2-3-I-x2F-O结构" class="headerlink" title="1.2.3 I&#x2F;O结构"></a>1.2.3 I&#x2F;O结构</h3><ol><li>Programmed I&#x2F;O（有规划的I&#x2F;O，我自己起的名字）<br> <img src="https://api2.mubu.com/v3/document_image/196fcb9d-ab73-4f9a-b469-5597801a2a89-15002533.jpg" alt="Programmed I/O"><ul><li>CPU没有拿到它想要的那一个word之前，就一直等着。一直等I&#x2F;O设备的status变成可用，然后给它读了那一个word，然后才结束。</li></ul></li><li>Interrupt-Driven I&#x2F;O（中断驱动的I&#x2F;O）<br> <img src="https://api2.mubu.com/v3/document_image/d2e6d7af-7924-49b4-b7a2-af2b9296020d-15002533.jpg" alt="Interrupt-Driven I/O"><ul><li>CPU给I&#x2F;O设备一个“我要用你了”的信号，然后就去做别的事情。等I&#x2F;O设备准备好了（或者出现了故障），会中断CPU的进程，然后为CPU做它想要做的事情。</li><li>同步I&#x2F;O：I&#x2F;O工作开始之后，一直等到I&#x2F;O完成，控制权才返还给用户。</li><li>异步I&#x2F;O：I&#x2F;O工作开始之后，控制权不等到I&#x2F;O完成就返还给用户。</li></ul></li></ol><ul><li><p>在实际的I&#x2F;O工作开始前，到底是不是在坐等I&#x2F;O设备可用是区分Programmed I&#x2F;O和I-D I&#x2F;O的标准。</p></li><li><p>在I-D I&#x2F;O中，是否坐等I&#x2F;O工作完成，是区分同步和异步I&#x2F;O的标准。</p></li><li><p>有两个东西方便实现上述功能</p><ol><li>设备状态表：设备处于什么状态</li><li>系统调用：操作系统要怎么用设备</li></ol></li><li><p>DMA(Direct Memory Access)</p><ul><li>高速（与存储器读写速度相近的）I&#x2F;O设备可以通过DMA一块一块的直接进行读写内存操作，中途不加CPU的干预</li><li>CPU只在I&#x2F;O开始和结束时介入。</li><li>每次读写一块数据时，CPU只在结束时被中断一次。</li><li>期间CPU可以做其他事情。</li></ul></li><li><p>I&#x2F;O通道控制程序</p><ul><li>与DMA类似</li><li>CPU通过I&#x2F;O指令控制I&#x2F;O设备</li><li>I&#x2F;O指令包括：通道号，I&#x2F;O设备号，通道程序的首地址</li><li>通道程序由若干通道指令组成</li><li>当CPU需要一系列I&#x2F;O操作时，只需要向I&#x2F;O通道发送一条I&#x2F;O指令即可。</li><li>通道程序举例<br><img src="https://api2.mubu.com/v3/document_image/feda3304-787c-4e8e-8b69-704db8e9de7c-15002533.jpg" alt="通道程序举例"><ul><li>P：&#x3D;1时代表是通道程序的最后一条指令</li><li>R：&#x3D;1时代表这一条指令是处理当前记录的最后一条指令</li></ul></li></ul></li></ul><h2 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h2><ul><li>单线编程：再执行一个任务时，到了I&#x2F;O环节，CPU总是要等I&#x2F;O进行完毕再进行下一个动作，CPU和IO设备永远不会同时工作。</li><li>多线编程：保证CPU一直在运转，将所有要做的工作存起来。在执行一个任务到了不得不等I&#x2F;O的环节时，操作系统切换到另一个工作。<br>  <img src="https://api2.mubu.com/v3/document_image/70f00b8b-83b6-4091-a8d6-27e8015248d3-15002533.jpg" alt="Multiprogramming"></li><li>时分复用<ul><li>CPU频繁的不同工作之间切换，确保用户可以在一个进程运行的期间和它交互</li><li>至少有一个工作在内存中执行</li><li>多个工作同时执行时要按照多线编程的方式选择工作进行</li><li>如果要进行的进程无法放进内存中，需要把内存中的东西移出去（有可能把别的工作移出去）。</li><li>多用户通过终端同时访问</li></ul></li><li>时分复用系统的特点<ul><li>I&#x2F;O规划由操作系统安排</li><li>操作系统为不同的工作分配内存</li><li>设立虚拟内存，为了使工作不只能在内存中进行</li><li>文件系统实现磁盘管理</li><li>安排CPU要做的事情，避免死锁</li><li>分配资源</li></ul></li></ul><h2 id="1-5-操作系统行为"><a href="#1-5-操作系统行为" class="headerlink" title="1.5 操作系统行为"></a>1.5 操作系统行为</h2><ul><li>现代操作系统是由中断驱动的</li><li>硬件触发的中断叫做Interrupt，软件叫做trap或exception</li><li>双模式行为：硬件支持系统处于两种状态下<ol><li>User mode: 用户执行</li><li>Monitor mode: 系统执行</li></ol></li><li>双模式行为：<ul><li>硬件设置标志位：0为Monitor mode，1为User mode</li><li>可以分辨当前处于什么模式</li><li>某些有特殊权限的指令只能在kernel mode下执行</li><li>一个system call就会转移到kernel mode，从system call返回时转移到user mode</li></ul></li><li>设立计时器防止资源一直被某一进程占用<ul><li>操作系统维护一个倒计时的计时器</li><li>当倒计时为0时，触发一个中断</li><li>在一个进程重获控制权时开始计时，在一个进程执行的时间超过预期时中断</li><li>用于改变这个计时器值的指令是一种特殊权限指令</li></ul></li></ul><h2 id="1-6-进程管理"><a href="#1-6-进程管理" class="headerlink" title="1.6 进程管理"></a>1.6 进程管理</h2><ul><li>进程是一个系统正在执行的程序，是系统工作的单位。</li><li>进程需要资源</li><li>进程在结束时需要把资源归还</li><li>单线程的进程只有一个PC，多线程的进程每个线程都有一个PC</li><li>不同处理器上同时运行着多个进程</li><li>操作系统需要管理以下和进程有关的事件<ul><li>创建&#x2F;销毁用户&#x2F;系统进程</li><li>挂起&#x2F;恢复执行进程</li><li>同步进程</li><li>进程通信</li><li>防止死锁</li></ul></li></ul><h1 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h1><h1 id="2-1-操作系统提供的功能和服务"><a href="#2-1-操作系统提供的功能和服务" class="headerlink" title="2.1 操作系统提供的功能和服务"></a>2.1 操作系统提供的功能和服务</h1><ol><li>一类用于方便用户使用<ul><li>用户交互，程序执行，I&#x2F;O，操纵文件，进程间通信，错误检测</li></ul></li><li>一类用于高效执行自己的业务<ul><li>分配资源，统计，保护</li><li>多用户可以通过分配资源来提高效率</li></ul></li></ol><h2 id="2-2-用户与系统交互的方式"><a href="#2-2-用户与系统交互的方式" class="headerlink" title="2.2 用户与系统交互的方式"></a>2.2 用户与系统交互的方式</h2><ul><li>CLI 命令行<ul><li>MS-DOS在内核中实现，内置命令</li><li>Windows和UNIX在系统程序中实现</li><li>Windows的命令控制界面<ul><li>运算符：&amp;，&amp;&amp;，||，（），；，%1</li><li>批处理文件：.bat和.cmd</li></ul></li></ul></li><li>GUI 图形化界面</li><li>操作系统汉化<ul><li>CCDOS：第一台长城机汉字操作系统</li><li>HHBIOS：CCDOS的进阶版</li><li>UCDOS：企业研发，性能优良，灵活方便</li><li>中文之星：Windows外围汉化代表</li></ul></li><li>语音控制（VUI）</li><li>图像</li><li>手势</li><li>脑机</li></ul><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用"></a>2.3 系统调用</h2><ul><li>对于系统提供的服务的编程式交互<ul><li>例：写一个打开a文件，把a文件中的内容写入b文件</li></ul></li><li>通常使用高级编程语言</li><li>多数由高级程序提供的接口（API）实现，而不是直接进行系统调用</li><li>API会提供一系列的函数方便编程者使用</li><li>常见的API：<ul><li>Windows API：Windows</li><li>POSIX API：UNIX，LINUX，macOS</li><li>Java：JVM</li></ul></li><li>API比直接进行系统调用有着更好的<strong>迁移性</strong>，且屏蔽了一些不需要的细节。</li><li>API<br>Windows API：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @retrun BOOL</span><br><span class="hljs-comment"> * @name ReadFile</span><br><span class="hljs-comment"> * @param file The file to be read</span><br><span class="hljs-comment"> * @param buffer A buffer where the data will be written or read from</span><br><span class="hljs-comment"> * @param bytes to read The number of bytes to be read next time</span><br><span class="hljs-comment"> * @param bytes read The number of bytes read to the buffer during the last read</span><br><span class="hljs-comment"> * @param ovl Indicates if overlapped I/O is used</span><br><span class="hljs-comment">*/</span><br>BOOL <span class="hljs-title function_">ReadFile</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE file,</span><br><span class="hljs-params">  LPVOID buffer,</span><br><span class="hljs-params">  DWORD bytes To Read,</span><br><span class="hljs-params">  LPDWORD bytes Read</span><br><span class="hljs-params">  LPOVERLAPPED ovl</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>UNIX and Linux：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @retrun ssize_t</span><br><span class="hljs-comment"> * @name read</span><br><span class="hljs-comment"> * @param fd The file descriptor to be read</span><br><span class="hljs-comment"> * @param buf A buffer where the data will be read into</span><br><span class="hljs-comment"> * @param conunt The maximum number of bytes to be read into the buffer</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure></li><li>支持运行时的系统会专门有一个<strong>系统调用交互</strong><ul><li>有一个系统调用索引表，每一个系统调用都对应一个数字</li><li>系统调用交互会：<ul><li>屏蔽API里的系统调用</li><li>启用OS中必要的系统调用</li><li>返回结果</li></ul></li></ul></li><li>用户并不知道系统调用是怎么做的，他们只需要知道怎么调用API和获得返回值就可以了。</li><li>向系统调用传递参数的三种方式<ol><li>寄存器</li><li>内存块</li><li>栈：程序入栈，OS出栈</li></ol></li></ul><h2 id="2-4-系统调用的类型"><a href="#2-4-系统调用的类型" class="headerlink" title="2.4 系统调用的类型"></a>2.4 系统调用的类型</h2><ol><li>进程控制</li><li>文件管理</li><li>设备管理</li><li>信息维护：获取，设置系统时间，文件属性</li><li>交流：进程间<ol><li>内存共享：借用内存共享块通信，不需要协助，不方便进程间同步，安全性差，高速量大</li><li>消息传递：用send和receive，包含系统调用，必须提前建立连接，效率较低但是可以保持同步，用于交换信息量较少的数据，安全性好</li></ol></li><li>保护：设置资源权限</li></ol><h2 id="2-5-系统程序"><a href="#2-5-系统程序" class="headerlink" title="2.5 系统程序"></a>2.5 系统程序</h2><ol><li>文件管理</li><li>状态信息</li><li>文件编辑</li><li>编程语言支持</li><li>程序加载和执行</li><li>用户，进程，系统间通信</li><li>系统工具</li><li>后台服务：自启动</li></ol><h2 id="2-6-操作系统的设计与实现"><a href="#2-6-操作系统的设计与实现" class="headerlink" title="2.6 操作系统的设计与实现"></a>2.6 操作系统的设计与实现</h2><ul><li>并不存在一个完美的解决方案</li><li>不同操作系统的内部原理相差甚远</li><li>从理清目的和特点出发</li><li>受硬件类型，操作系统类型（批处理，时分复用…）影响</li><li><h2 id="难以具体化目标-用户：易用，性能强大，可靠，快速-系统：易实现，易维护，可靠，高效，可迁移"><a href="#难以具体化目标-用户：易用，性能强大，可靠，快速-系统：易实现，易维护，可靠，高效，可迁移" class="headerlink" title="难以具体化目标- 用户：易用，性能强大，可靠，快速- 系统：易实现，易维护，可靠，高效，可迁移"></a>难以具体化目标<br>- 用户：易用，性能强大，可靠，快速<br>- 系统：易实现，易维护，可靠，高效，可迁移</h2></li><li>设计和实现一个操作系统是软件工程中极具创造性的工作</li><li>将<em>目标（Policy）</em>从<em>手段（Machanism）</em>中分离出来<ul><li>二者分离是实现灵活性的重要途径</li></ul></li><li>操作系统的实现<ul><li>相差甚远</li><li>时间发展顺序：汇编语言————Alogol，PL&#x2F;1————C，C++</li><li>实际上是多种语言的混杂，底层汇编，主体C，系统程序C&#x2F;C++，Python，PERL，shell scrpits</li><li>更多的高级语言会导致<ul><li>硬件之间的迁移性好</li><li>运行速度变慢</li></ul></li><li>仿真可以让操作系统运行在非原生的硬件上</li></ul></li><li>影响操作系统性能的重要因素：优秀的数据结构和算法</li><li>只有小部分代码的性能对系统总体性能有至关重要的影响<ul><li>中断处理，I&#x2F;O处理</li><li>内存管理，CPU管理</li></ul></li><li>在可以正常工作后，优化<strong>瓶颈</strong>：将其转换为等价的汇编语言</li></ul><h2 id="2-7-操作系统结构"><a href="#2-7-操作系统结构" class="headerlink" title="2.7 操作系统结构"></a>2.7 操作系统结构</h2><h2 id="2-9-迁移操作系统"><a href="#2-9-迁移操作系统" class="headerlink" title="2.9 迁移操作系统"></a>2.9 迁移操作系统</h2><ul><li>一个SYSGGEN文件用来描述操作系统所需的硬件参数<ul><li>CPU，内存大小，设备，缓冲区大小</li></ul></li><li>迁移操作系统的方式<ul><li>复制并修改原本操作系统的源代码</li><li>选择之前操作系统库中的部分功能</li><li>配置一个合适的表用来描述系统</li></ul></li></ul><h2 id="2-9-启动操作系统"><a href="#2-9-启动操作系统" class="headerlink" title="2.9 启动操作系统"></a>2.9 启动操作系统</h2><ul><li>Booting：通过加载内核启动计算机</li><li>Bootstrap Program：一小段在ROM中的程序，定位内核，将其加载进内存，启动执行</li><li>两步走<ol><li>bootstrap loader：诊断初始化系统，将boot program写入内存准备执行</li><li>boot program：将整个操作系统加载进内存开始执行</li></ol></li></ul><h1 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h1><h2 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h2><ul><li><p>执行中的<strong>程序</strong>叫<strong>进程</strong></p></li><li><p><strong>程序</strong>：静态存储在磁盘上的可执行文件</p></li><li><p><strong>进程</strong>：程序加载进内存开始动态执行成为进程</p></li><li><p>一个进程内包括：</p><ul><li>程序代码</li><li>数据区：全局变量</li><li>堆：动态分配的内存</li><li>栈：临时变量，包括：函数参数，返回地址，局部变量</li><li>当前操作：程序计数器</li></ul></li><li><p>进程在执行过程中会改变状态</p></li><li><p>一个进程总是在以下几个状态之一：</p><ul><li>新创建</li><li>正在执行</li><li>等待：等待某个事件的发生</li><li>就绪：准备加载到一个处理器开始执行</li><li>终止</li></ul></li><li><p>一个处理器只能同时执行一个进程，其他进程都在等待和就绪<br><img src="https://api2.mubu.com/v3/document_image/2c694e86-f2f9-4c0f-ac73-6db9a161b1da-15002533.jpg" alt="进程状态"></p></li><li><p>每个进程都由一个进程控制块（PCB）反映</p></li><li><p>一个程序块中包含：</p><ul><li>进程状态</li><li>程序计数器</li><li>CPU寄存器</li><li>CPU给它的规划：优先级，执行队列</li><li>内存管理信息</li><li>统计信息：总共用了多少CPU时间，当前时间片用了多少时间，时间限制是多少…</li><li>I&#x2F;O信息：打开的文件，分配给进程的I&#x2F;O设备</li><li>进程ID</li></ul></li><li><p>进程在状态之间转换的时机</p><ul><li>时钟打断：已经执行到了最大时间</li><li>I&#x2F;O打断</li><li>内存错误：访问到虚拟内存，必须从外存把数据带进来</li><li>异常</li><li>系统调用</li></ul></li><li><p>一个进程中可以有多个<strong>线程</strong></p><ul><li>多个线程可以同时进行</li><li>在PCB中记录多个程序计数器</li></ul></li></ul><h2 id="3-2-进程调度"><a href="#3-2-进程调度" class="headerlink" title="3.2 进程调度"></a>3.2 进程调度</h2><ul><li><p>multiprogramming的目的：最大化CPU利用率</p></li><li><p>时分复用的目的：让用户可以在一个进程执行时与它交互</p></li><li><p>调度队列</p><ul><li>工作队列：系统中所有进程</li><li>就绪队列：系统中所有就绪的进程</li><li>一般用链表存储</li></ul></li><li><p>设备队列：每个设备有一个属于自己的队列，用于记录等着要使用它的进程<br><img src="https://api2.mubu.com/v3/document_image/08b88b03-9743-4802-9f4a-3916c4be0772-15002533.jpg" alt="队列图"></p></li><li><p>长周期调度（job scheduler）</p><ul><li>选择进入就绪队列的进程</li><li>不频繁被打断</li><li>长周期调度要控制同时在内存里的进程数量</li></ul></li><li><p>短周期调度（CPU scheduler）</p><ul><li>选择下一个要执行的进程</li><li>频繁被打断</li></ul></li><li><p>进程可以分为以下两类</p><ol><li>绑定I&#x2F;O的进程</li><li>绑定CPU的进程</li></ol></li><li><p>绑定I&#x2F;O的进程多了，就会有很多进程卡在等待状态，就绪队列的进程很少，CPU调度不需要做什么工作</p></li><li><p>绑定CPU的进程多了，很多进程都会在就绪状态，设备队列的进程就很少，硬件会大量闲置</p></li><li><p>中周期调度(medium term scheduler)</p><ul><li>将就绪队列和设备队列里的进程换进（到内存）换出（到磁盘），让两个队列比较均衡</li><li>CPU处理的比I&#x2F;O设备快，所以所有进程可能都在设备队列</li><li>这时候把设备队列里的进程换出，状态变为<strong>挂起等待</strong></li><li>新增两个状态<ol><li><strong>挂起等待</strong></li><li><strong>挂起就绪</strong></li></ol></li><li>换出的原因：<ul><li>CPU需要为一个要执行的进程腾出一些内存空间</li><li>系统怀疑有一个进程产生了异常</li><li>用户主动要求</li><li>一个进程是每过一段固定时间才执行</li><li>父进程要求</li></ul></li></ul></li><li><p>语境切换<br>每次CPU切换要执行的进程时，要进行语境切换。一个进程的语境存储在PCB里，语境切换包括以下步骤：</p><ol><li>保存处理器的执行环境：包括程序计数器和寄存器状态</li><li>更新当前正在执行的进程PCB</li><li>把PCB挪到它应该去的地方</li><li>选择另一个要执行的进程</li><li>更新要执行的进程的PCB</li><li>更新内存管理数据结构</li><li>恢复要执行的进程的语境</li></ol></li><li><p>语境切换是顶级操作：CPU在这个过程中不做任何实际的工作</p></li><li><p>切换速度取决于硬件</p></li></ul><h2 id="3-3-进程操作"><a href="#3-3-进程操作" class="headerlink" title="3.3 进程操作"></a>3.3 进程操作</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><ul><li>创建进程的原因<ol><li>执行一项批处理工作</li><li>用户登录</li><li>要打印东西</li><li>被其他进程创建</li></ol></li><li>创建进程的步骤<ol><li>给新进程分配一个ID</li><li>给新进程分配内存空间</li><li>初始化PCB</li><li>进行合适的链接：让需要知道这个进程存在的东西都知道它被创建了，比如把它连进CPU调度链表</li><li>创建别的数据结构：比如一个统计信息表</li><li>确定资源共享方案：共享父进程的所有资源，共享父进程的部分资源，不和父进程共享资源</li><li>当一个进程被创建时，他可能包含着从父进程传给它的初始化参数</li></ol></li><li>执行时的两种可能：<ol><li>与父进程同步执行</li><li>父进程等待他的一些子进程结束后继续执行</li></ol></li><li>地址空间的两种可能：<ol><li>与父进程完全相同</li><li>有一段程序专门加载子进程的地址空间</li></ol></li><li>PPT上的练习</li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><ul><li>终止进程的原因<ul><li>正常执行结束</li><li>执行时间超过限制</li><li>内存不可用</li><li>越界访问</li><li>越权操作：尝试写入只读文件</li><li>算数异常：分母为0</li><li>等待（I&#x2F;O）时间超过最大值</li><li>I&#x2F;O失败</li><li>错误指令</li><li>越权指令：用户进程试图执行只有内核才能执行的指令</li><li>数据异常：类型不匹配</li><li>操作系统介入：死锁</li><li>父进程终止</li><li>父进程要求子进程终止</li></ul></li><li>进程执行了最后一条指令，请求操作系统删除它<ul><li>将数据还给父进程</li><li>收回分配的资源</li></ul></li><li>父进程要终止子进程的原因<ul><li>子进程用了超出给它分配的内存空间</li><li>分配给子进程的任务已经不再需要了</li><li>父进程自己要终止</li></ul></li></ul><h2 id="3-4-进程间通信"><a href="#3-4-进程间通信" class="headerlink" title="3.4 进程间通信"></a>3.4 进程间通信</h2><ul><li><p><strong>独立进程</strong>不会影响其他进程执行，也不会被其他进程执行影响</p></li><li><p><strong>合作进程</strong>会影响其他进程执行，也会被其他进程执行影响</p></li><li><p>两个基础模型</p><ol><li>共享内存：可以达到通信的最高速度和便利性，可以以内存读写的速度进行通信</li><li>通信管道：适用于数据量小的通信，因为不需要考虑读写冲突；跨计算机通信更好实现</li></ol></li><li><p>共享内存系统——生产者-消费者问题</p><ul><li>一个经典模式：<strong>生产者</strong>进程生产数据，<strong>消费者</strong>进程消费数据</li><li>我们要提供一个缓冲区，让生产者把数据放进来填满，让消费者搬空<ul><li>生产者生产和消费者消费可以同时进行</li><li>两者必须同步（synchorize）</li></ul></li><li>两种缓冲区<ol><li>无界缓冲区</li><li>有界缓冲区：循环队列</li></ol></li></ul></li><li><p>通信管道——IPC</p><ul><li>通信并同步他们的执行节奏</li><li>建立一个管道，然后通过<code>send()</code>和<code>receive()</code>通信</li><li>管道的介质<ul><li>物理介质：共享内存，硬件总线，网络</li><li>逻辑介质：逻辑属性</li></ul></li><li>直接通信<ul><li>进程之间必须显式指定通信双方的名字</li><li>两个通信进程之间有且仅有一根管道（可单向可双向）</li></ul></li><li>间接通信<ul><li>进程之间依赖邮箱通信，一个进程把数据放到信箱里，另一个进程来取</li><li>一个信箱可能有多个进程使用</li><li>两个进程之间可能用多个信箱</li></ul></li><li>如何杜绝间接通信中的冲突问题<ol><li>最多允许两个进程共享一个信箱</li><li>最多同时允许一个进程调用<code>receive()</code>函数</li><li>让系统随机选择一个接收者，让发送者知道谁拿到了</li></ol></li><li>一个信箱可以被操作系统或者进程占用</li><li>如果这个信箱是被进程创建的<ul><li>这个进程只能用这个信箱接受信息</li><li>别的进程只能往这个信箱发送信息</li></ul></li><li>如果这个信箱是系统创建的：不属于任何进程</li><li>操作系统向进程提供以下几种操作<ul><li>创建和删除一个信箱</li><li>从信箱中接收消息，发送信息到信箱</li></ul></li><li>同步&#x2F;异步</li><li>限制发送者<ul><li>通道0容量：发送者必须等接收者可以接收的时候才能发</li><li>通道n容量：发送者必须等通道有空闲了再发</li><li>通道无限容量：发送者的发送不受任何限制</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机</title>
    <link href="/2022/03/12/FormalLanguageAndAutomata/"/>
    <url>/2022/03/12/FormalLanguageAndAutomata/</url>
    
    <content type="html"><![CDATA[<h1 id="形式语言与自动机"><a href="#形式语言与自动机" class="headerlink" title="形式语言与自动机"></a>形式语言与自动机</h1><h2 id="第二章-语言及文法"><a href="#第二章-语言及文法" class="headerlink" title="第二章 语言及文法"></a>第二章 语言及文法</h2><h3 id="2-1-语言的定义与运算"><a href="#2-1-语言的定义与运算" class="headerlink" title="2.1 语言的定义与运算"></a>2.1 语言的定义与运算</h3><ul><li><p>字母表</p></li><li><p>字符串</p></li><li><p>字符串的运算</p></li><li><p>前缀后缀和子串</p><blockquote><p>空串是任何字符串的前缀后缀和字串</p></blockquote></li><li><p>字符串$\omega$的逆用$\bar{\omega}$表示</p></li><li><p>字母表的幂运算</p><ol><li>$T^0&#x3D;\lbrace\varepsilon\rbrace$</li><li>设$x\in T^{n-1}, a\in T$，则$ax\in T^n$</li><li>T^n中的元素只能由前两条生成</li></ol></li><li><p>*闭包：$T^* &#x3D; T^0\cup T^1\cup T^2\cup\cdots$</p></li><li><p>+闭包：$T^+ &#x3D; T^1\cup T^2\cup T^3\cup\cdots$</p></li><li><p>$T^* &#x3D; T^+\cup\lbrace\varepsilon\rbrace,T^+ &#x3D; T^*-\lbrace\varepsilon\rbrace$</p></li><li><p>语言：设$T$为字母表，则任何集合$L\subseteq T^*$是字母表$T$上的一个语言</p></li><li><p>举例：设$T&#x3D;\{a, b\}$<br>  则 $L_1&#x3D;\{a^nb^n|n\ge 1\}$<br>  $L_2&#x3D;\{b^k|k是质数\}$<br>  $L_3&#x3D;\{\varepsilon\}$ &#x2F;&#x2F; 只有一个空句子的语言<br>  $L_4&#x3D;\{\} &#x3D; \emptyset$ &#x2F;&#x2F; 空语言</p></li><li><p>语言的积：集合的有序笛卡尔积（我自己编的话），所以$L_1L_2\neq L_2L_1$</p></li><li><p>语言的幂</p></li></ul><h3 id="2-2-文法"><a href="#2-2-文法" class="headerlink" title="2.2 文法"></a>2.2 文法</h3><p>文法是用来定义语言的数学模型</p><ul><li><p>BNF（巴科斯范式）</p><ul><li>&lt;数字&gt;::&#x3D;0|1|2|…9  &#x2F;&#x2F; ::&#x3D;读作“定义为”</li><li>&lt;字母&gt;::&#x3D;A|B|C|…Z|a|b|…z</li><li>&lt;标识符&gt;::&#x3D;&lt;字母&gt;|&lt;标识符&gt;&lt;字母&gt;|&lt;标识符&gt;&lt;数字&gt;</li></ul></li><li><p><strong>Chomsky文法体系</strong><br>  文法是一个四元组$G&#x3D;(N,T,P,S)$，其中</p><ul><li>N 非终结符的有限集合</li><li>T 终结符的优先级合 $N\cap T&#x3D;\emptyset$</li><li>P 形式为$\alpha \rightarrow \beta$的生成式的有限集合。且$\alpha\in (N\cup T)^*N^+(N\cup T)^*,\beta\in(N\cup T)^*$</li><li>S 起始符 且$S\in N$</li></ul></li><li><p>例子见课件</p></li></ul><h3 id="2-3-Chomsky文法体系分类"><a href="#2-3-Chomsky文法体系分类" class="headerlink" title="2.3 Chomsky文法体系分类"></a>2.3 Chomsky文法体系分类</h3><ul><li><p>0型文法：无限制</p></li><li><p>1型文法：1）左部长度小于右部 2）不含$A\rightarrow \varepsilon$</p></li><li><p>2型文法：左部是单个非终结符</p></li><li><p>3型文法：</p><ol><li>$A\rightarrow \omega B$或$A\rightarrow \omega$</li><li>$A\rightarrow B\omega$或$A\rightarrow \omega$</li></ol></li><li><p>四类文法之间的包含关系搞清楚。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>形式语言与自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2022/03/02/ComputerArchitecture/"/>
    <url>/2022/03/02/ComputerArchitecture/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="第一章-计算机系统概论"><a href="#第一章-计算机系统概论" class="headerlink" title="第一章 计算机系统概论"></a>第一章 计算机系统概论</h2><h3 id="1-2-计算机的发展简史"><a href="#1-2-计算机的发展简史" class="headerlink" title="1.2 计算机的发展简史"></a>1.2 计算机的发展简史</h3><h4 id="1-2-4-计算机的性能指标"><a href="#1-2-4-计算机的性能指标" class="headerlink" title="1.2.4 计算机的性能指标"></a>1.2.4 计算机的性能指标</h4><ul><li><strong>主频&#x2F;时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟是不断产生固定频率的钟。主时钟的频率叫做CPU的主频（f）度量单位为MHz或GHz（吉赫兹）；主频的倒数被称为时钟周期（T）度量单位是$\mu s$，$ns$。</li><li><strong>CPU执行时间</strong><br>$$<br>CPU执行时间&#x3D;CPU时钟周期数\times CPU时钟周期<br>$$</li><li><strong>CPI</strong>：表示每条指令需要的时钟周期数<br>$$<br>CPI&#x3D;执行某段程序需要的时钟周期数\div 这段程序的指令数<br>$$</li><li><strong>MIPS</strong>：平均每秒执行多少百万指令数<br>$$<br>MIPS&#x3D;指令数\div (程序执行时间\times 10^6)<br>$$</li><li><strong>FLOPS</strong>：每秒执行浮点操作的次数<br>$$<br>FLOPS&#x3D;程序中浮点操作的次数\div 程序执行时间<br>$$</li></ul><h3 id="1-3-计算机的硬件"><a href="#1-3-计算机的硬件" class="headerlink" title="1.3 计算机的硬件"></a>1.3 计算机的硬件</h3><ol><li>运算器：完成算数和逻辑运算操作，也称为数据通路</li><li>存储器：存放程序和数据</li><li>控制器：根据取得的指令向其他部件发出控制信号，完成指令规定操作</li><li>输入&#x2F;输出设备：完成人与计算机的相互通信</li></ol><h2 id="第二章-运算方法和运算器"><a href="#第二章-运算方法和运算器" class="headerlink" title="第二章 运算方法和运算器"></a>第二章 运算方法和运算器</h2>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/03/02/ComputerNetwork/"/>
    <url>/2022/03/02/ComputerNetwork/</url>
    
    <content type="html"><![CDATA[<p>新学期开始营业</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="1-2-网络硬件"><a href="#1-2-网络硬件" class="headerlink" title="1.2 网络硬件"></a>1.2 网络硬件</h3><ul><li><p>按照传输技术分类，分为两种：</p><ul><li><strong>点到点（point-to-point）</strong><ul><li>在诸多路由中找到一条最好的路径</li><li>只有一个发送方和接收方</li></ul></li><li><strong>广播（broadcasting）</strong><ul><li>一台机器向所有机器发送消息</li><li>接受的其余所有机器先检查地址字段，如果自己的地址就是就是这个消息的目的地，就处理此消息，否则忽略</li></ul></li></ul></li><li><p>按照传输距离分类：</p><ul><li>1米：个域网（PAN）</li><li>10米～1千米：局域网（LAN）</li><li>10千米：城域网（MAN）</li><li>100千米～1000千米：广域网（W）</li><li>10000千米：互联网（Internet）</li></ul></li></ul><blockquote><p>有趣的事情：当”internet”一词首字母小写的时候，指的是一堆互联的机器，也就是互联网；而当这一词首字母大写的时候（即”Interney”），特指的就是链接世界上所有机器的因特网。因特网是一种特殊的互联网。</p></blockquote><h3 id="1-3-网络软件"><a href="#1-3-网络软件" class="headerlink" title="1.3 网络软件"></a>1.3 网络软件</h3><h4 id="1-3-1-协议层次结构"><a href="#1-3-1-协议层次结构" class="headerlink" title="1.3.1 协议层次结构"></a>1.3.1 协议层次结构</h4><p><img src="https://api2.mubu.com/v3/document_image/690ed93c-17fa-4c89-9fe2-8522c077ee89-15002533.jpg" alt="协议层次结构"></p><ul><li><p>第n-1层的协议为第n层提供服务的接口，可以理解为一种封装。所以在保证提供的服务不变的情况下，第n-1层协议的实现细节可以任意改变。</p></li><li><p>两台机器进行交流的时候，并不是直接从一个机器的第n层传输到另一个机器的第n层，而是从一个机器的第n层到第n-1层，再到第n-2层，直到最底层，传输到另一台机器，再通过协议一层层恢复到第n层。</p></li><li><p>层和协议的集合被称为<strong>网络体系结构</strong>。</p></li></ul><p>下面分析一下上图的消息传输过程：<br>    1. 一个应用程序在第5层产生了一个消息（M），交由第4层。<br>    2. 第4层为这个消息加上了一个头（$H_4$），该头包含了一些控制信息（如地址），然后交由第3层。<br>    3. 第3层将第4层的内容进行分割，因为通常情况下一次传输的消息长度是被限制的，而第4层传来的消息可能过于长，所以第三层将这些消息分割为更小的<strong>包</strong>（packet）。然后再为每个更小的包加上一个头，其中可能包含这些包的次序信息。然后交由第2层。<br>    4. 第二层除了在每个包的前面加上了一个头，还在每个包的结尾处加上了一个尾（T）。最后交由第一层进行传输。</p><h4 id="1-3-2-层次设计问题"><a href="#1-3-2-层次设计问题" class="headerlink" title="1.3.2 层次设计问题"></a>1.3.2 层次设计问题</h4><ul><li>可靠性：网络传输线路本身由并不可靠的组件构成，所以要保证可靠性是非常关键的问题。首先可以考虑的是一种优秀的编码方案可以检错和纠错（离散下群码有说）。然后就是自动智能的修改信息传输的路由途径。</li><li>可扩展性：网络功能逐渐复杂，网络规模逐渐扩大。如人口过多手机号不够用或者城市过大找不到家这类的问题。一个解决方案：层和协议</li><li>资源分配：该给谁什么时候分配多少带宽，什么样的服务质量（QoS），什么样的即时水平。</li><li>网络安全</li></ul><h4 id="1-3-3-面向连接和无连接的服务"><a href="#1-3-3-面向连接和无连接的服务" class="headerlink" title="1.3.3 面向连接和无连接的服务"></a>1.3.3 面向连接和无连接的服务</h4><ul><li><strong>面向连接的服务</strong>（connection-oriented service）：这种服务是模拟电话系统的，一方提起电话拨打号码，另一方提起电话应答。在网络中双方和传递过程中的媒介通常会提前商量好要求的最长消息长度，服务质量等。</li><li><strong>无连接服务</strong>（connectionless service）：这种服务是模拟邮政系统的，每一个发送的报文都带有完整的地址信息，通过系统的中间路由自己寻找路径到达目的地。这一行为与之前和之后的报文都无关，一般情况下先发送的报文会先到达目的地，但因为网络状况的不同，不同批次的报文并不总是和发送顺序一样的到达目的地的。</li><li>可靠的和不可靠的服务：可靠与不可靠和是否面向连接无关。<br><img src="https://api2.mubu.com/v3/document_image/6de5b5f2-befc-4461-88b0-75807addf1f3-15002533.jpg" alt="各种网络服务"><br>从上图发现，一般要求顺序正确的都采用面向连接的服务，不要求顺序的都采用无连接的服务。</li></ul><h3 id="1-3-4-服务原语"><a href="#1-3-4-服务原语" class="headerlink" title="1.3.4 服务原语"></a>1.3.4 服务原语</h3><p>一系列用于交流的指令。</p><h3 id="1-3-5-协议和服务的关系"><a href="#1-3-5-协议和服务的关系" class="headerlink" title="1.3.5 协议和服务的关系"></a>1.3.5 协议和服务的关系</h3><p><strong>服务</strong>是指某一层向他上一层提供的原语（操作），不涉及这些操作是如何定义的，服务的对象是层。</p><p><strong>协议</strong>与服务的具体实现有关，它们对用户是完全不可见的，协议的对象是数据包。</p><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="2-1-数据通信的理论基础"><a href="#2-1-数据通信的理论基础" class="headerlink" title="2.1 数据通信的理论基础"></a>2.1 数据通信的理论基础</h3><h4 id="2-1-1-数据通信的性能指标"><a href="#2-1-1-数据通信的性能指标" class="headerlink" title="2.1.1 数据通信的性能指标"></a>2.1.1 数据通信的性能指标</h4><p><em>基础概念</em></p><ul><li><p><strong>信道（Channel）</strong>：传输信息的媒体</p></li><li><p><strong>数据率（Bit Rate）</strong>：数据传输速率（bps）</p><blockquote><p>&#x3D;1秒&#x2F;每一个高电平或低电平持续的时间</p></blockquote></li><li><p><strong>波特（Baud）</strong>：码元传输速率</p><blockquote><p>&#x3D;$(\log_2V)$bps，其中V是信号的电平级数。如果传输的信号只有高电平（5V）代表1，低电平（0V）代表0，那么电平级数就是2，此时波特速率&#x3D;比特速率；如果传输的信号有0V-255V共256个电平级数，相当于一个单位的信息代表了之前8个0或1的信息量，此时波特速率就是8倍的比特速率。</p></blockquote></li><li><p><strong>传播速度（Propagation Speed）</strong>：通信线路上，信号单位时间内传播的距离。光速：$3\times 10^8$m&#x2F;s；铜线：$2\times 10^8$m&#x2F;s。</p></li><li><p><strong>带宽（Bandwidth）</strong>：信号占用的频率范围（Hz）</p></li><li><p><strong>信道容量（Channel Capacity）</strong>：信道的最大数据率，防止低配置的机器被数据淹没。</p></li><li><p><strong>吞吐量（Throughput）</strong>：网络容量的度量，表示单位时间内网络可以传送的数据位数（后常用包作为单位）</p></li><li><p><strong>误码率BER（Bit Error Rate）</strong>：信道传输可靠性指标</p><blockquote><p>P&#x3D;传送错的位数&#x2F;传送总位数</p></blockquote></li><li><p><strong>时延（Delay）</strong>：从向网络中发送数据块的第一比特开始，到最后一位数据被接收所经历的时间</p><blockquote><p><mark>时延&#x3D;传播时延+发送时延</mark>+处理时延+排队时延<br><mark>传播时延 &#x3D; 距离&#x2F;传播速度</mark><br><mark>发送时延 &#x3D; 包比特量&#x2F;数据率</mark></p></blockquote></li><li><p><strong>单工通信（Simplex）</strong>：数据传输只能单向进行（FM广播）</p></li><li><p><strong>半双工通信（Half-deplex）</strong>：可以交替地（不同时地）进行双向通信（对讲机）</p></li><li><p><strong>全双工通信（Full-duplex）</strong>：可以同时进行双向通信（电话）</p></li><li><p><strong>并行通信（Parallel transmission）</strong><br><img src="https://api2.mubu.com/v3/document_image/59fca9d6-221c-44f0-967a-bc364de2afcf-15002533.jpg" alt="并行通信"></p></li><li><p><strong>串行通信（Serial transmission）</strong><br><img src="https://api2.mubu.com/v3/document_image/97610a0c-a6cf-40b4-b028-5647e6ec34e0-15002533.jpg" alt="串行通信"><br>串行通信又分为：</p><ul><li><strong>异步通信（Asynchronous Transmission）</strong><br><img src="https://api2.mubu.com/v3/document_image/8ebb9c8e-4d61-42bc-ada0-c7d393a4d9b2-15002533.jpg" alt="异步通信"><ul><li>独立时钟（传输只需要一来一回两条线和地线，共3条）</li><li>以字符为单位进行传输</li><li>发送两个字符之间的间隔是任意的</li><li>接收方依靠字符中的起始位和停止位同步</li><li>成本低，近距离低速传输</li></ul></li><li>**同步通信（Synchoronous Transmission）<br><img src="https://api2.mubu.com/v3/document_image/28f122d9-29ca-48fb-af6b-f4f88882a623-15002533.jpg" alt="同步通信"><ul><li>以时钟信号线对传输的数据线上的信号进行比特同步（传输需要一来一回两条线，时钟两条线，地线一条，共5条线）</li><li>以数据块，帧或分组为单位传输</li><li>成本高，远距离高速传输</li></ul></li></ul></li></ul><h4 id="2-1-2-带宽有限的信号"><a href="#2-1-2-带宽有限的信号" class="headerlink" title="2.1.2 带宽有限的信号"></a>2.1.2 带宽有限的信号</h4><p>传输字母’b’的例子<br><img src="https://api2.mubu.com/v3/document_image/239eeac1-77df-4d38-b18c-49dad7ea147b-15002533.jpg"></p><ul><li>假设在我们的例子中，比特率为b比特&#x2F;秒，那么传输8比特（一次发送一个比特）就需要8&#x2F;b秒（周期T），一次谐波的频率就是b&#x2F;8Hz（频率f），在人为引入的截止频率是3000的情况下，最大谐波数（$a_n$，$b_n$的角标能取到几）为3000&#x2F;(b&#x2F;8)，即24000&#x2F;b。<br><img src="https://api2.mubu.com/v3/document_image/86d51c21-5ea3-4341-ad7f-90dff6accbff-15002533.jpg"></li><li>需要注意的是，<mark>带宽</mark>一词，有时指的是频率（Hz）就像上文所说的那样，有时指的是一个信道的最大数据速率（bps）。需要根据上下文语境判断。</li></ul><h4 id="2-1-3-信道的最大数据速率"><a href="#2-1-3-信道的最大数据速率" class="headerlink" title="2.1.3 信道的最大数据速率"></a>2.1.3 信道的最大数据速率</h4><ul><li><strong>尼奎斯特（Nyquist）定理</strong>：<br>$$<br>  C &#x3D; 2B\log_2V<br>$$<br>其中B为带宽（Hz），V为电平级数。C是算出来的最大数据速率（比特&#x2F;秒）</li><li><strong>香农（Shannon）定理</strong>：<br>$$<br>  C &#x3D; 2B\log_2(1+S&#x2F;N)<br>$$<br>其中S&#x2F;N是信噪比，一般用分贝表示<br>$$<br>  (S&#x2F;N)_{db} &#x3D; 10\times \log_{10} (S&#x2F;N)<br>$$</li></ul><h3 id="2-2-引导性传输介质"><a href="#2-2-引导性传输介质" class="headerlink" title="2.2 引导性传输介质"></a>2.2 引导性传输介质</h3><h4 id="2-2-1-磁介质"><a href="#2-2-1-磁介质" class="headerlink" title="2.2.1 磁介质"></a>2.2.1 磁介质</h4><ul><li>把信息录入到磁带里，用货运方式运过去。</li></ul><h4 id="2-2-2-双绞线"><a href="#2-2-2-双绞线" class="headerlink" title="2.2.2 双绞线"></a>2.2.2 双绞线</h4><ul><li><p>之所以将两根铜线缠绕在一起，是因为两根行的线会构成一个很好的天线。当两根线绞在一起后，不同电线产生的干扰波会相互抵消，从而能显著降低电线的辐射。信号通常以两根电线的电压差来承载，这样对外部噪声有更好的免疫力</p></li><li><p>到6类为止，所有的双绞线都称为非屏蔽双绞线(UTP, Unshielded Twisted Pair)，这些双绞线仅由导线和绝缘层简单地构成。相对应地，7类双绞线在每对双绞线外面加了个屏蔽层，然后在整个线缆外面再加一个屏蔽层(内层的是塑料保护套)。屏蔽层能够减弱外部干扰和来自附近线缆的串扰，从而满足苛刻的性能规范要求。</p></li></ul><h4 id="2-2-3-同轴电缆"><a href="#2-2-3-同轴电缆" class="headerlink" title="2.2.3 同轴电缆"></a>2.2.3 同轴电缆</h4><p>后面的太多了，感觉不关键，到时候有空再说。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理复习笔记</title>
    <link href="/2021/12/12/basicPrinciplesofMarxism/"/>
    <url>/2021/12/12/basicPrinciplesofMarxism/</url>
    
    <content type="html"><![CDATA[<p>共同作者：<a href="https://blog.szhhh.top/">涵</a><del>（等她有了博客就做成超链接）</del>她已经有博客了。</p><p>属于是一个速成的粗制滥造的复习笔记，没有任何全面性，有时间就多补充一点，先记一记这些东西让自己不挂科再说。主要参见<a href="https://blog.xqmmcqs.com/">神的博客</a>制成。</p><h1 id="马克思主义基本原理"><a href="#马克思主义基本原理" class="headerlink" title="马克思主义基本原理"></a>马克思主义基本原理</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="一、什么是马克思主义"><a href="#一、什么是马克思主义" class="headerlink" title="一、什么是马克思主义"></a>一、什么是马克思主义</h3><ol><li>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系。</li><li>三个基本组成部分：<ul><li>马克思主义哲学</li><li>马克思主义政治经济学</li><li>科学社会主义</li></ul></li><li>马克思主义的<mark>基本立场</mark>：以无产阶级的解放和全人类的解放为己任，以人民为中心，坚持一切为了人民，一切依靠人民，全心全意为人民谋幸福。</li><li>马克思主义的<mark>基本观点</mark>：关于自然、社会和人类思维发展一般规律的科学认识，是对人类思想成果和社会实践经验的科学总结。<font size =2>1. 关于世界统一于物质，物质决定意识的观点2. 关于事物矛盾运动规律的观点3. 关于实践和认识辩证关系的观点4. 关于社会存在决定社会意识的观点5. 关于人与自然和谐共生的观点6. 关于人类社会发展规律的观点7. 关于世界历史的观点8. 关于阶级和阶级斗争的观点9. 关于人民群众创造历史的观点10. 关于人的全面发展和社会全面进步的观点11. 关于商品经济和社会化大生产一般规律的观点12. 关于劳动价值论，剩余价值论，和资本主义生产方式本质的观点13. 关于资本主义政治制度和意识形态本质的观点14. 关于垄断资本主义的观点15. 关于社会主义必然代替资本主义的观点16. 关于社会主义革命和无产阶级专政的观点17. 关于共产主义社会基本特征和共产主义远大理想的观点18. .etc</font></li><li>马克思主义的<mark>基本方法</mark>：建立在<strong>辩证唯物主义</strong>和<strong>历史唯物主义</strong>世界观和方法论基础上，指导我们正确认识世界和改造世界的思想方法和工作方法。</li></ol><h3 id="二、马克思主义的创立与发展"><a href="#二、马克思主义的创立与发展" class="headerlink" title="二、马克思主义的创立与发展"></a>二、马克思主义的创立与发展</h3><h4 id="（一）马克思主义的创立"><a href="#（一）马克思主义的创立" class="headerlink" title="（一）马克思主义的创立"></a>（一）马克思主义的创立</h4><ol><li><p>资本主义生产方式带来的深重社会灾难：</p><ol><li>社会两极分化，工人极端困苦</li><li>周期性经济危机频繁爆发</li></ol></li><li><p>19世纪西欧三大先进思潮为马克思主义的创立提供了直接的理论来源。</p><ul><li>德国古典哲学(<strong>辩证法</strong>)</li><li>英国古典政治经济学(对<strong>资本主义生产关系</strong>的分析和关于<strong>劳动创造价值</strong>的思想,可概括为<strong>劳动价值论</strong>)</li><li>英法两国的空想社会主义(对资本主义社会的批判和对未来新社会的展望)</li></ul></li><li><p>19世纪的三大科学发现为马克思主义的产生提供了<u>自然科学前提</u>。</p><ul><li>细胞学说</li><li>能量守恒与转化定律</li><li>生物进化论</li></ul></li><li><p>《德法年鉴》表明他们完成了从唯心主义向唯物主义、从革命民主主义向共产主义的转变，为创立马克思主义奠定了思想前提。</p></li><li><p>《德意志意识形态》<strong>首次系统阐述了历史唯物主义的基本观点</strong>，实现了历史观上的伟大变革。</p></li><li><p>《共产党宣言》是世界上第一个无产阶级政党的党纲，是<strong>马克思主义公开问世的标志</strong>。</p></li><li><p>马克思主义的鲜明特征：科学性和革命性的统一。<br>又可以讲 科学性，人民性，实践性，发展性。<br>或者 认识世界 和 改造世界</p></li><li><p>马克思主义的中国化：<br><strong>毛泽东思想，邓小平理论，三个代表重要思想，科学发展观，习近平新时代中国特色社会主义</strong>。掐头去尾中间三个统称(忘了，总之有个统称)  </p></li><li><p><strong>列宁</strong>科学的剖析了帝国主义的经济基础，深刻矛盾和统治危机，提出了<strong>社会主义革命可能在一国或者数国首先发生并取得胜利的论断</strong>。</p></li><li><p>马克思主义的当代价值：</p><ol><li>观察当代世界变化的认识工具</li><li>指引当代中国发展的行动指南</li><li>引领人类社会进步的科学真理</li></ol></li></ol><h2 id="第一章-世界的物质性及发展规律"><a href="#第一章-世界的物质性及发展规律" class="headerlink" title="第一章 世界的物质性及发展规律"></a>第一章 世界的物质性及发展规律</h2><h3 id="1-1-世界的多样性与物质统一性"><a href="#1-1-世界的多样性与物质统一性" class="headerlink" title="1.1 世界的多样性与物质统一性"></a>1.1 世界的多样性与物质统一性</h3><ol><li><p>世界观：对世界的一个总体的看法和把握</p></li><li><p>哲学 是系统化，理论化的世界观</p></li><li><p>哲学的基本问题：存在和思维的关系问题，又称物质和意识的关系问题。</p><ul><li>存在和思维，物质和意识谁是本源(何者为第一性) <font color=blue>区分唯物和唯心</font></li><li>存在和思维，物质和意识(是否具有同一性),思维能否正确反映存在，人能否认识或彻底认识世界？<font color=blue>可知论与不可知论</font></li></ul></li><li><p><strong>古代朴素唯物主义</strong>：用一种或几种物质作为本源(五行)</p></li><li><p><strong>近代形而上学唯物主义</strong>：把物质等同于原子，却不能正确理解哲学的物质概念和自然科学的物质概念之间共性和个性的关系，经不起自然科学进一步发展的检验，也经不起唯心主义的进攻。</p></li><li><p><strong>列宁对物质的定义(物质最准确的定义，没有之一):</strong> 物质是标志<strong>客观实在</strong>的哲学范畴，这种客观实在是人<strong>通过感觉感知</strong>的，它<strong>不依赖于我们的感觉存在</strong>，为我们的<strong>感觉所</strong>复写，摄影，<strong>反映</strong>。</p></li><li><p>坚持<strong>唯物主义一元论</strong>，同<strong>唯心主义一元论和二元论</strong>划清了界限；坚持了<strong>能动的反映论和可知论</strong>，批判了<strong>不可知论</strong>(只有尚未认知，没有不可知)；<strong>唯物论和辩证法的统一</strong>，克服了<strong>形而上学</strong>唯物主义的缺陷；唯物主义<strong>自然观和历史观</strong>的统一，为<strong>彻底的唯物主义</strong>奠定了基础。后两点是马克思最伟大的成就了。</p></li><li><p>世界物质的统一性原理及其意义</p><ol><li><p>原理：</p><ol><li><p>世界是统一的(against二元论)</p></li><li><p>世界是统一于物质的(against唯心主义)</p></li><li><p>世界的统一是多样性的统一(against旧唯物主义)</p></li></ol></li><li><p>意义：</p><ol><li><p>理论意义：它是马克思主义哲学的基石</p></li><li><p>实践意义：它是我们从事一切工作的立足点，一切从实际出发是唯物主义一元论的根本要求</p></li></ol></li></ol></li></ol><h4 id="物质与意识的辩证关系-意识的能动作用"><a href="#物质与意识的辩证关系-意识的能动作用" class="headerlink" title="物质与意识的辩证关系 意识的能动作用"></a>物质与意识的辩证关系 意识的能动作用</h4><ol><li><p>物质与意识的辩证关系</p><ol><li><p>物质决定意识</p><ol><li>物质对意识的决定作用表现在意识的起源和本质上</li><li>意识的<strong>本质</strong>：人脑的机能和属性，自然界长期发展的产物，社会历史发展的产物</li><li>意识的<strong>起源</strong>：由一切物质所具有的反应特性到低等生物的刺激感应性，再到高等动物的感觉和心理，最终发展为人类的意识(意识只有人具有)</li></ol><ul><li><strong>社会实践，特别是劳动</strong>，在意识的产生和发展中起着<strong>决定</strong>性的作用，<strong>语言促进</strong>了意识的发展。</li></ul></li><li><p>意识反作用于物质(也就是意识的<strong>能动作用</strong>，这个可以考大题)</p><ul><li>可以用造飞机的过程来记</li></ul><ol><li>意识具有目的性和计划性(想飞行，所以观察鸟)</li><li>意识具有创造性(想到了如果有一种机器可以飞，创造性)</li><li>意识具有指导实践改造客观世界的作用(造飞机)</li><li>意识具有调控人的行为和生理活动的作用(坐飞机的时候暗示自己不紧张)</li></ol></li></ol><blockquote><p>上课补充–<strong>论述意识能动性的主要表现，在实际工作、学习中如何正确发挥人的主观能动性？</strong><br>（首先写上面那四点）<br>正确发挥意识的能动作用是有条件的。这种条件性的根本点在于，更科学的把握物质和意识的辩证关系，把意识的能动性建立于物质决定论的理论基础之上，具体说，其一、从实际出发，努力认识和把握事物的发展规律；其二、实践是发挥人的主观能动性的基本途径；其三、主观能动性的发挥还依赖于一定的物质条件和物质手段。</p></blockquote></li><li><p>客观规律性和主观能动性的关系</p><ol><li><p><strong>一方面，尊重客观规律是正确发挥主观能动性的前提</strong>。规律是事物发展变化过程中本身所固有的内在的、本质的、必然的联系。人们只有在认识和掌握客观规律的基础上，才能达到认识和改造世界的目的（得先知道怎么改造,顺应天时才有可为）</p></li><li><p><strong>另一方面，只有充分发挥主观能动性，才能正确认识和利用客观规律。</strong>（知道了就要去做）</p></li></ol></li></ol><h4 id="正确发挥主观能动性"><a href="#正确发挥主观能动性" class="headerlink" title="正确发挥主观能动性"></a>正确发挥主观能动性</h4><ol><li><p>正确发挥主观能动性</p><ol><li><p><mark>从实际出发</mark>，努力认识和把握事物的发展规律（先认识规律）(前提)</p></li><li><p><mark>实践</mark>是发挥人的主观能动性的根本途径（然后就去做）</p></li><li><p>发挥主观能动性需要依赖于一定的<mark>物质条件和物质手段</mark>（量力而为，需要工具和现实的物质）</p></li></ol></li></ol><h3 id="1-2-事物的普遍联系和变化发展"><a href="#1-2-事物的普遍联系和变化发展" class="headerlink" title="1.2 事物的普遍联系和变化发展"></a>1.2 事物的普遍联系和变化发展</h3><h4 id="联系和发展的普遍性"><a href="#联系和发展的普遍性" class="headerlink" title="联系和发展的普遍性"></a>联系和发展的普遍性</h4><ul><li>辩证唯物法认为，世界上的万事万物都处在普遍的联系中，普遍联系引起事物的运动和发展。<strong>联系和发展的观点是唯物辩证法的<font color=red>总观点</font>，集中体现了唯物辩证法的<font color=red>总特征</font>。</strong>(唯物辩证法要求从联系中看到区别，区别中看到联系)</li></ul><ol><li>联系的特点<ol><li>客观性</li><li>普遍性(有三层含义：事物内部的不同部分之间，事物与事物之间，整个世界)</li><li>多样性</li><li>条件性(三点，要辩证的去看。条件是一个约束或者支持，条件是可以改变的，条件的改变不是任意的)</li></ol></li></ol><blockquote><p>世界是过程的集合体，而不是即成事物的集合体。</p></blockquote><ol start="2"><li><p><strong>发展</strong>的<strong>定义</strong>：事物变化中前进的，上升的运动。其<strong>实质</strong>是新事物的产生和旧事物的灭亡。(新事物不一定产生在旧事物之后，判断新旧的标准是<strong>是否合乎历史前进方向</strong>，是否具有远大前途)</p></li><li><p>为什么新事物必然战胜旧事物？</p><ol><li>新事物与环境的关系而言…</li><li>新事物与旧事物的关系而言…</li></ol></li><li><p><strong>why对立统一规律是唯物辩证法的<font color=red>实质和核心</font></strong></p><ol><li>对立统一规律揭示了事物普遍联系的根本内容和变化发展的内在动力，从根本上回答了事物为什么会发展的问题</li><li>对立统一规律是贯穿质变量变规律，否定之否定规律以及唯物辩证法基本范畴的中心和线索，也是理解这些规律的钥匙</li><li>对立统一规律提供了人们认识世界和改造世界的根本方法——矛盾分析法</li></ol></li></ol><hr><h4 id="矛盾的同一性-统一属性-和斗争性-对立属性-的关系-作用"><a href="#矛盾的同一性-统一属性-和斗争性-对立属性-的关系-作用" class="headerlink" title="矛盾的同一性(统一属性)和斗争性(对立属性)的关系 作用"></a>矛盾的同一性(统一属性)和斗争性(对立属性)的关系 作用</h4><ol><li><p>矛盾的同一性：是指矛盾双方相互依存，相互贯通的性质和趋势</p></li><li><p>矛盾的斗争性：是指矛盾着的对立面之间相互排斥、相互分离的性质和趋势</p></li><li><p>矛盾的同一性和斗争性相互联结，相辅相成。没有斗争性就没有同一性，没有同一性也没有斗争性。因为同一性是以差别和对立为前提的；斗争性寓于同一性之中，同一性通过斗争性来体现。</p><blockquote><p>矛盾的同一性是有条件的，相对的；矛盾的斗争性是无条件的，绝对的。矛盾的同一性和斗争性相结合，构成了事物的矛盾运动，推动着事物的变化和发展</p></blockquote></li></ol><p>（其实并不是很懂他在说什么，但他说是那就是）。</p><ol start="4"><li><p>矛盾的同一性和斗争性在事物发展中的作用  &#x2F;&#x2F; （和课本上的不完全一样</p><ol><li><p>矛盾是事物发展的动力。矛盾着的对立面又斗争又同一，由此推动事物的发展</p></li><li><p>其中同一性的作用主要表现在</p><ol><li><p>矛盾的双方可以通过对方的发展而使自己发展</p></li><li><p>矛盾的双方可以互相吸收有利于自身的因素进行发展</p></li><li><p>矛盾的双方可以向着自己的对立面转化而得到发展</p></li></ol></li><li><p>其中斗争性的作用主要表现在</p><ol><li><p>斗争推动双方力量发生变化，造成事物的量变(为对立面的转化，事物的质变创造条件）</p></li><li><p>斗争使得双方的地位或性质转化，实现事物的质变</p></li></ol></li></ol></li></ol><hr><h4 id="矛盾的普遍性和特殊性"><a href="#矛盾的普遍性和特殊性" class="headerlink" title="矛盾的普遍性和特殊性"></a>矛盾的普遍性和特殊性</h4><ol><li><p>矛盾的普遍性：指矛盾存在于一切事物中，存在于一切事物发展过程的始终，即所谓矛盾无处不在，无时不有。</p></li><li><p>矛盾的特殊性：指具体事物在其运动中的矛盾及每一矛盾的各个方面都有其特点。（决定了事物的不同性质）具体表现为：</p><ol><li><p>不同事物的矛盾各有其特点</p></li><li><p>同一事物的矛盾在不同发展过程和发展阶段各有不同特点</p></li><li><p>构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质、地位和作用。</p></li></ol></li><li><p>矛盾的特殊性和普遍性的关系：<strong>辩证统一</strong></p><blockquote><p>矛盾的普遍性(共性)是无条件的，绝对的，矛盾的特殊性(个性)是有条件的，相对的。任何现实存在是事物的矛盾都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。</p></blockquote></li></ol><hr><h4 id="矛盾的不平衡发展原理"><a href="#矛盾的不平衡发展原理" class="headerlink" title="矛盾的不平衡发展原理"></a>矛盾的不平衡发展原理</h4><ol><li><p>矛盾的不平衡发展原理：</p><p>其中<mark>根本矛盾</mark>贯彻事物发展过程的始终，规定着事物的性质；<mark>主要矛盾</mark>是矛盾体系中处于<strong>支配地位</strong>，对事物发展起<strong>决定作用</strong>的矛盾。每一对矛盾中又有矛盾的<mark>主要方面</mark>和<mark>次要方面</mark>，<strong>矛盾的性质</strong>主要是由矛盾的主要方面决定的。<br><strong>事物的性质</strong>是由主要矛盾的主要方面决定的。<br>要坚持<strong>两点论</strong>和<strong>重点论</strong>的统一。</p></li></ol><hr><h4 id="量变和质变-关系"><a href="#量变和质变-关系" class="headerlink" title="量变和质变 关系"></a>量变和质变 关系</h4><ol><li><p>事物发展过程中的量变和质变</p><ol><li><p>由于任何事物都是质和量的统一体，因而事物的变化表现为质变和量变两种运动状态</p></li><li><p>量变是<strong>事物数量的增减</strong>和<strong>组成要素排列次序</strong>的变动，是保持事物的质的相对稳定的不显著的变化，<mark>体现了事物发展渐进过程的连续性</mark>。</p></li><li><p>质变是事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，<mark>体现了事物发展渐进过程和连续性的中断</mark>。</p></li><li><p>区分量变还是质变的根本标志是事物的变化<mark>是否超出度</mark>，在度的范围内的变化是量变，超出度的变化是质变</p></li></ol></li><li><p>量变和质变的辩证关系</p><ol><li><p><mark>量变是质变的必要准备</mark>，任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。</p></li><li><p><mark>质变是量变的必然结果，并为新的量变开辟道路</mark>，单纯的量变不会一直持续下去，量变达到一定程度必然引起质变</p></li><li><p><mark>量变和质变是相互渗透的</mark>，在总的量变过程中有局部性或阶段性的质变；在质变的过程中也有旧质在量上的收缩和新质在量上的扩张。</p></li><li><p><mark>Summary </mark>量变和质变是相互依存，相互贯通的，量变引起质变在新质的基础上，事物又开始新的量变，如此交替循环，构成了事物的发展过程。</p></li><li><p>量变质变规律揭示了事物发展的形式和状态，体现了事物发展<strong>渐进性</strong>和<strong>飞跃性</strong>的统一。</p></li></ol></li><li><p>量变质变规律具有重要的方法论意义。</p><ol><li><p>当事物的发展处于量变阶段时，踏踏实实做好日常工作，为未来重大改变做准备</p></li><li><p>当质变来临时，要抓住机遇，促成质变，使工作迈上新台阶</p></li></ol></li></ol><hr><h4 id="事物发展过程中的肯定与否定及其相互转化-否定之否定规律"><a href="#事物发展过程中的肯定与否定及其相互转化-否定之否定规律" class="headerlink" title="事物发展过程中的肯定与否定及其相互转化(否定之否定规律)"></a>事物发展过程中的肯定与否定及其相互转化(否定之否定规律)</h4><ol><li><p><mark>事物内部都存在着肯定因素和否定因素</mark>。肯定因素是维持现存事物存在的因素，否定因素是促使现存因素灭亡的因素。</p></li><li><p><strong>唯物辩证法的否定观</strong>的基本内容：</p><ol><li><p><strong>否定是事物的自我否定，自我发展</strong>，是事物内部矛盾运动的结果</p></li><li><p><strong>否定是事物发展的环节，是旧事物向新事物的转变，是从旧质到新质的飞跃</strong>。只有经过否定，旧事物才能向新事物转变。</p></li><li><p><strong>否定新旧事物联系的环节</strong>，新事物孕育产生于旧事物，新事物是通过否定环节联系起来的。</p></li><li><p><strong>辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素</strong>。</p></li></ol></li><li><p>坚持辩证的否定观，就是要对一切事物采取科学分析的态度，要同时看到事物的肯定方面和否定方面。</p></li><li><p>否定之否定规律：事物的辩证发展就是经过两次否定，出现三个阶段，即“<mark>肯定——否定——否定之否定</mark>”，形成一个周期。波浪、螺旋上升。</p></li><li><p>否定之否定规律揭示了事物发展的<strong>前进性</strong>与<strong>曲折性</strong>的统一。前进性体现在每一次否定都是质变，都把事物推进到新阶段。曲折性体现在回复性上，其中有暂时的停顿甚至是倒退，这表明事物的发展不是直线前进，而是螺旋上升的。</p></li></ol><hr><h4 id="联系和发展的基本环节"><a href="#联系和发展的基本环节" class="headerlink" title="联系和发展的基本环节"></a>联系和发展的基本环节</h4><p>(这块儿有点杂碎，也没细看，就列个大纲在这，回头万一做题遇到了再说，总而言之就是除了对立统一，量变质变，否定之否定之外，唯物辩证法的一些<u>成对</u>的范畴)</p><ol><li>内容与形式</li><li>本质与现象</li><li>原因与结果</li><li>必然与偶然</li><li>现实与可能</li></ol><hr><h3 id="1-3唯物辩证法是认识世界和改造世界的根本方法"><a href="#1-3唯物辩证法是认识世界和改造世界的根本方法" class="headerlink" title="1.3唯物辩证法是认识世界和改造世界的根本方法"></a>1.3唯物辩证法是认识世界和改造世界的根本方法</h3><h4 id="唯物辩证法的本质特征和认识功能"><a href="#唯物辩证法的本质特征和认识功能" class="headerlink" title="唯物辩证法的本质特征和认识功能"></a>唯物辩证法的本质特征和认识功能</h4><ol><li><p>唯物辩证法本质上是批判的和革命的</p></li><li><p>唯物辩证法是客观辩证法与主观辩证法的统一</p></li><li><p>唯物辩证法是科学的认识方法，既是科学的世界观，又是认识和改造世界的基本方法论</p></li></ol><ul><li><p>矛盾分析法是对立统一规律在方法论上的体现，在唯物辩证法体系中居于核心地位，是我们认识事物的根本方法。</p></li><li><p>习近平指出，解决深层次的矛盾&amp;问题，根本出路在于<strong>创新</strong>。</p></li></ul><hr><h2 id="第二章-实践与认识及其发展规律"><a href="#第二章-实践与认识及其发展规律" class="headerlink" title="第二章 实践与认识及其发展规律"></a>第二章 实践与认识及其发展规律</h2><h3 id="2-1-实践与认识"><a href="#2-1-实践与认识" class="headerlink" title="2.1 实践与认识"></a>2.1 实践与认识</h3><p>(意识来源于物质，实践是物质的，认识来源于实践)</p><h4 id="实践三要素"><a href="#实践三要素" class="headerlink" title="实践三要素"></a>实践三要素</h4><ol><li><p>实践是 <strong>人类 <font color=green>能动</font></strong> 地改造世界的 <strong>社会性的物质活动</strong></p><ul><li><font size=2>实践是人类独有的</font></li></ul></li><li><p>实践的<mark>主体</mark>，<mark>客体</mark>，<mark>中介</mark>是实践活动的三项基本要素，三者的有机统一构成实践的基本结构。</p><ol><li>主体是人，但不是所有的人都是主体</li><li>客体是物，但不是所有的物都是客体</li><li>中介是各种工具手段以及运用操控这些工具的程序和方法</li></ol></li><li><p>实践的基本特征：(xx性即是本质)</p><ol><li><p>实践是改造世界的客观物质活动，具有<u><strong>客观实在性</strong></u>（把脑中的东西变成现实的）</p></li><li><p>实践是人类有意识的活动，体现了<u><strong>自觉的能动性</strong></u>（受意识的指导）</p></li><li><p>实践是社会的，历史的活动，具有<u><strong>社会历史性</strong></u>（不同历史阶段的实践意义不同）</p></li></ol></li><li><p>实践的基本形式</p><ol><li>物质生产劳动实践–劳动</li><li>社会政治实践–搞关系</li><li>科学文化实践–探索</li></ol></li></ol><ul><li>人的活动：分为本能活动和实践活动</li></ul><hr><h4 id="实践对认识的决定作用"><a href="#实践对认识的决定作用" class="headerlink" title="实践对认识的决定作用"></a>实践对认识的决定作用</h4><ol><li><p>实践是认识的来源。首先，实践产生了认识的需要，其次，实践还为认识的形成提供了可能。</p></li><li><p>实践是认识发展的动力  </p></li><li><p>实践是认识的目的</p></li><li><p>实践是检验认识真理性的唯一标准</p></li></ol><h4 id="认识对实践的指导作用"><a href="#认识对实践的指导作用" class="headerlink" title="认识对实践的指导作用"></a>认识对实践的指导作用</h4><ol><li>实践必须受意识的支配，这决定了它离不开认识的指导</li><li>认识的成果具有相对独立性，它一经形成，便能够指导实践。</li><li>认识指导实践表现在很多方面，找规律，定目标，选方式，创理论，改自身</li><li>认识反作用于实践有两种情况：正确的认识促进&#x2F;错误的认识阻碍 实践(所以错误的认识也能指导实践，是意识就能指导实践)</li></ol><h4 id="理论：认识的高级形式"><a href="#理论：认识的高级形式" class="headerlink" title="理论：认识的高级形式"></a>理论：认识的高级形式</h4><ol><li>理论是对事物本质和规律的认识，它可以并且应该走在实践的前面，指导实践的进程</li><li>科学理论能预见未来，端正实践的方向</li><li>科学理论作为一种精神力量，能推动人们在实践中创新</li></ol><hr><h4 id="实践检验真理标准的确定性和不确定性"><a href="#实践检验真理标准的确定性和不确定性" class="headerlink" title="实践检验真理标准的确定性和不确定性"></a>实践检验真理标准的确定性和不确定性</h4><p>必须把实践对真理的检验，看作是<mark>全部人类实践</mark>即无数个别、历史发展着的、整个社会的实践<mark>对真理的检验</mark>。实践检验和真理证明是一个过程，这个过程永远不会完结。</p><hr><h4 id="感性认识和理性认识的关系-飞跃的基本条件"><a href="#感性认识和理性认识的关系-飞跃的基本条件" class="headerlink" title="感性认识和理性认识的关系 飞跃的基本条件"></a>感性认识和理性认识的关系 飞跃的基本条件</h4><ol><li><p>从实践中产生感性认识，然后能动地飞跃到理性认识，这是认识过程的第一次飞跃</p><ol><li><p><strong>感性认识</strong>是认识的低级阶段，是人在实践基础上由感觉器官感受到的关于事物的现象、事物的外部联系、事物的各个方面的认识，它包括感觉，知觉，表象三种形式，其突出特点是<mark>直接性</mark>。</p></li><li><p><strong>理性认识</strong>是认识的高级阶段，是人借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物的本质、全体、内部联系和事物自身规律的认识，它包括概念判断推理及假说和理论等形式，其特点是<mark>间接性</mark>和<mark>抽象性</mark>。</p></li></ol></li><li><p>感性认识和理性认识之间的关系是辩证统一的：</p><ol><li><p>理性认识依赖于感性认识</p></li><li><p>感性认识有待于发展和深化为理性认识</p></li><li><p>感性认识和理性认识互相渗透，相互包含</p></li></ol></li><li><p>感性认识和理性认识的辩证关系是在实践中形成的，也需要在实践中发展</p></li><li><p>感性认识到理性认识的条件：</p><ol><li><p>勇于实践，深入调查，获取丰富和合乎实际的感性材料</p></li><li><p>必须经过理性思考的作用，将丰富的感性材料加工制作</p></li></ol></li><li><p>从认识到实践的飞跃是认识过程的第二次飞跃，是更为重要的一次飞跃</p><ol><li><p>（实践的角度）<mark>认识世界目的是改造世界，此外别无目的</mark>，回到实践才能指导实践</p></li><li><p>（认识的角度）认识的真理性只有在实践中才能检验</p></li></ol></li><li><p>实现从认识到实践的飞跃，需要经过一定的中介环节，包括确定实践目的，形成实践理念，制定实践方案等。</p></li></ol><hr><h4 id="理性因素和非理性因素"><a href="#理性因素和非理性因素" class="headerlink" title="理性因素和非理性因素"></a>理性因素和非理性因素</h4><ol><li><p>理性因素是指的人的理性直观，理性思维等能力。它的作用主要有，指导作用，解释作用，预见作用</p></li><li><p>非理性因素是指人的情感，意志，包括动机，信仰，习惯，本能等，以非逻辑因素出现的幻想，想象，直觉等也属于非理性因素。它的作用有，动力作用，诱导作用，激发作用。</p></li></ol><hr><h4 id="认识的规律"><a href="#认识的规律" class="headerlink" title="认识的规律"></a>认识的规律</h4><ul><li><strong>反复性</strong></li></ul><p>人们对于一个复杂事物的认识，往往要经过由感性认识到理性认识，再由理性认识到实践的多次反复才能完成。<br>原因：从客观看，事物暴露有个过程<br>从主观看，主体认识能力提高有个过程</p><ul><li><strong>无限性</strong></li></ul><p>认识发展的无限性是指，对于事物发展过程的推移来说，人类的认识是永无止境，无限发展的，它表现为“实践，认识，再实践，再认识”的无限循环，由低级阶段向高级阶段不断推移的永无止境的前进运动。这种认识到无限发展过程，在形式上是循环往复，在实质上是前进上升。</p><h3 id="2-2-真理与价值"><a href="#2-2-真理与价值" class="headerlink" title="2.2 真理与价值"></a>2.2 真理与价值</h3><h4 id="真理的性质"><a href="#真理的性质" class="headerlink" title="真理的性质"></a>真理的性质</h4><ol><li><p>真理具有<mark>客观性</mark>，其含义是：</p><ol><li><p>真理是客观的，真理包含着不以人的意志为转移的客观内容</p></li><li><p>真理的标准是客观的，客观的社会实践是检验真理的唯一标准</p></li></ol></li><li><p>真理的客观性决定了真理的<mark>一元性</mark></p><ol><li><p>真理的一元性是指在同一条件下对于特定的认识客体的真理性认识只有一个，而不可能有多个。</p></li><li><p>认识是多元的，但真理是一元的。</p></li><li><p>真理是一元的是针对真理的客观内容而言的，单从真理的主观形式来看，真理的表现又是多样的。真理是内容上的一元性与形式上的多样性的统一。</p></li></ol></li><li><p>真理的<mark>绝对性</mark>和<mark>相对性</mark></p><ol><li><p>真理绝对性的含义：一是任何真理都必然包含同客观现象相符合的客观内容，都同谬误有着原则上的界限，这一点是绝对的，无条件的；二是人类认识按其本性来说，能够正确认识无限发展着的物质世界，认识每前进一步，都是对它的一种接近，这一点也是绝对的，无条件的。</p></li><li><p>真理的相对性：一是真理所反映的对象是有条件的、有限的；二是真理反映客观对象的正确程度也是有条件的、有限的。</p></li><li><p>真理绝对性和相对性的辩证统一：</p><ol><li><p>两者相互依存，因为每一个正确认识都是在一定范围，一定程度上的，但又是绝对正确的；</p></li><li><p>两者相互包含；</p></li><li><p>真理永远处在由相对向绝对的转化和发展中。</p></li><li><p>真理的绝对性和相对性根源于人类认识世界能力的无限性与有限性、绝对性与相对性的矛盾。</p></li></ol></li></ol></li></ol><hr><h4 id="真理与谬误（对立统一）"><a href="#真理与谬误（对立统一）" class="headerlink" title="真理与谬误（对立统一）"></a>真理与谬误（对立统一）</h4><ol><li><p>谬误是同客观事物及其发展规律相违背的认识，是对客观事物及其发展规律的歪曲反映。</p></li><li><p>真理和谬误相互对立。<mark>在确定的条件下</mark>，一种认识不能即是真理又是谬误。</p></li><li><p>真理和谬误的对立又是相对的，他们在一定程度上可以相互转化。因为<mark>他们的对立只是在非常有限的范围内才有意义</mark>。一方面因为真理是具体的，真理都是在一定范围内才成立的，超出这个范围就会变成谬误。另一方面真理又是全面的，把全面科学的真理孤立地，断章取义的隔离出来，也会变成谬误。</p></li></ol><hr><h4 id="真理与价值（辩证统一）"><a href="#真理与价值（辩证统一）" class="headerlink" title="真理与价值（辩证统一）"></a>真理与价值（辩证统一）</h4><ol><li><p>实践的真理尺度：是指在实践中人们必须遵守正确反映客观事物本质和<mark>规律</mark>的真理。</p></li><li><p>实践的价值尺度：是指人们都是按照自己的尺度和需要去认识和改造世界。这一尺度体现了人的活动的<mark>目的性</mark>。</p></li><li><p>任何实践活动都是在这两种尺度的共同制约下进行的，任何成功的实践都是真理尺度和价值尺度的统一，是<mark>合规律性</mark>和<mark>合目的性</mark>的统一。</p></li><li><p>真理与价值在实践中是辩证统一的。一方面，价值尺度必须以真理为前提；另一方面脱离了价值尺度，真理就失去了主体意义。</p></li></ol><blockquote><p>真理尺度和价值尺度会随着实践的发展而不断发展到更高级的程度。基于实践的具体性和历史性，真理尺度和价值尺度也是具体的和历史的。新时代中国特色社会主义伟大实践，充分体现了真理尺度和价值尺度的辩证统一。</p></blockquote><hr><h2 id="第三章-人类社会及其发展规律"><a href="#第三章-人类社会及其发展规律" class="headerlink" title="第三章 人类社会及其发展规律"></a>第三章 人类社会及其发展规律</h2><h3 id="3-1-人类社会的存在与发展"><a href="#3-1-人类社会的存在与发展" class="headerlink" title="3.1 人类社会的存在与发展"></a>3.1 人类社会的存在与发展</h3><h4 id="社会存在"><a href="#社会存在" class="headerlink" title="社会存在"></a>社会存在</h4><p><img src="https://api2.mubu.com/v3/document_image/c46474be-21e6-49a2-b764-918db00d174b-15002533.jpg" alt="社会存在"></p><h4 id="社会意识"><a href="#社会意识" class="headerlink" title="社会意识"></a>社会意识</h4><p><img src="https://api2.mubu.com/v3/document_image/a1305f9b-a7bd-408f-a2c9-298d51481bcf-15002533.jpg" alt="社会意识"></p><h4 id="社会存在和社会意识辩证关系原理"><a href="#社会存在和社会意识辩证关系原理" class="headerlink" title="社会存在和社会意识辩证关系原理"></a>社会存在和社会意识辩证关系原理</h4><ol><li><p><mark>社会存在决定社会意识</mark>：社会存在是社会意识内容的客观来源;随着社会存在的发展，社会意识也会相应地或迟或早的发生变化和发展。</p></li><li><p><mark>社会意识是社会存在的反映</mark>：社会意识是人们进行<strong>社会物质交往</strong>的产物</p></li><li><p><mark>社会意识反作用于社会存在</mark></p><p><font color=gray size=2>社会意识的相对独立性</font></p></li><li><p>社会意识与社会存在发展存在<mark>不完全同步性</mark>和<mark>不平衡性</mark>。<br>进步的社会意识可以预见，推断未来，指导人们的实践活动；落后的社会意识会阻碍社会的发展。社会经济水平高的国家不一定有高水平的社会意识，社会经济水平低的国家也不一定社会意识落后。</p></li><li><p>社会意识内部各种形式之间相互影响及各自具有的历史继承性</p></li></ol><hr><h4 id="生产力和生产关系"><a href="#生产力和生产关系" class="headerlink" title="生产力和生产关系"></a>生产力和生产关系</h4><ol><li><p>生产力是人类在生产时间中形成的改造和影响自然以使其适合社会需要的物质力量，生产力具有<mark>客观现实性</mark>和<mark>社会历史性</mark>。</p></li><li><p>生产力的基本要素</p><ol><li><p><mark>劳动手段</mark>：生产工具，生产力发展水平的尺度</p></li><li><p><mark>劳动对象</mark>：原材料，成品</p></li><li><p><mark>劳动者</mark>：劳动的人</p></li></ol></li><li><p>生产关系是人们在物质生产过程中形成不以人的意志为转移的经济关系。生产关系是社会关系中<mark>最基本的关系</mark>。生产关系包括生产资料所有制关系，生产中人与人的关系和产品分配关系。</p></li><li><p>生产力与生产关系的关系是：<mark>生产力决定生产关系</mark>，<mark>生产关系反作用于生产力</mark>。二者的有机统一构成社会的生产方式。</p></li><li><p>一方面生产力的状况决定生产关系的性质，生产力的发展决定生产关系的变化；另一方面生产关系反作用于生产力，当生产关系适合生产力的状况时对生产力发展起着促进作用，反之起阻碍作用。</p></li></ol><h4 id="经济基础与上层建筑"><a href="#经济基础与上层建筑" class="headerlink" title="经济基础与上层建筑"></a>经济基础与上层建筑</h4><ul><li><p>经济基础是指由社会一定发展阶段的生产力所决定的生产关系的总和。(经济基础是生产关系)</p></li><li><p>上层建筑是建立在一定的经济基础之上的意识形态以及与之相适应的制度，组织，措施。</p></li><li><p>意识形态(观念上层建筑)，就是社会意识形态，包括人文社科的学科</p></li><li><p>政治法律制度及设施和政治组织(政治上层建筑，是主导)，包括国家政治制度，立法司法制度和行政制度，以及国家政权机构(是核心)、政党、军队、警察、法庭、监狱等政治组织形态和设施。</p></li></ul><blockquote><p>上层建筑与社会意识形态</p></blockquote><p><img src="https://api2.mubu.com/v3/document_image/4a1715d1-1a69-4f43-b0a5-0041f21d839d-15867716.jpg" alt="上层建筑与社会意识形态"></p><h4 id="经济基础与上层建筑的矛盾运动及其规律"><a href="#经济基础与上层建筑的矛盾运动及其规律" class="headerlink" title="经济基础与上层建筑的矛盾运动及其规律"></a>经济基础与上层建筑的矛盾运动及其规律</h4><ol><li><p>经济基础决定上层建筑，经济基础决定上层建筑的产生、性质和变化发展</p></li><li><p>上层建筑反作用于经济基础，集中表现在：上层建筑为自己的经济基础的形成和巩固服务(根本是是否适合生产力)</p></li></ol><h3 id="3-3-人民群众在历史发展中的作用"><a href="#3-3-人民群众在历史发展中的作用" class="headerlink" title="3.3 人民群众在历史发展中的作用"></a>3.3 人民群众在历史发展中的作用</h3><h4 id="人民群众是历史的创造者"><a href="#人民群众是历史的创造者" class="headerlink" title="人民群众是历史的创造者"></a>人民群众是历史的创造者</h4><ol><li><p>人民群众是一个历史范畴。<mark>从质上说</mark>是指一切对社会历史发展起推动作用的人们，<mark>从量上说</mark>是指社会人口中的绝大多数。</p></li><li><p>人民群众最稳定的主体部分始终是从事物质资料生产的劳动群众。</p></li><li><p>在社会历史发展中，人民群众<mark>起着决定性的作用</mark>，人民群众是历史的主体，<mark>是历史的创造者</mark>。</p><ol><li><p>人民群众是物质财富的创造者</p></li><li><p>人民群众是社会精神财富的创造者</p></li><li><p>人民群众是社会变革的决定力量</p></li></ol><p>历史是人民群众创造的，但人民群众创造历史的活动受到一定社会历史条件的制约。</p></li><li><p>马克思主义群众观点的主要内容是：坚信人民群众自己解放自己的观点，全心全意为人民服务的观点，一切向人民群众负责的观点，虚心向群众学习的观点。</p></li></ol><h4 id="历史人物"><a href="#历史人物" class="headerlink" title="历史人物"></a>历史人物</h4><ul><li><p>def：历史人物是一定历史事件的主要倡导者，组织领导者或思想理论，科学文化的重要代表人物。</p></li><li><p>历史人物的作用：</p><p> 1&gt; 历史人物是历史任务的提出者</p><p> 2&gt; 历史人物是历史事件的当事者</p><p> 3&gt; 历史人物是历史进程的影响者</p></li><li><p>评价历史人物时要坚持历史分析法和阶级分析法</p></li></ul><h4 id="群众、阶级、政党和领袖"><a href="#群众、阶级、政党和领袖" class="headerlink" title="群众、阶级、政党和领袖"></a>群众、阶级、政党和领袖</h4><p><strong>群众</strong>是划分为<strong>阶级</strong>的，<strong>阶级</strong>通常是由<strong>政党</strong>领导的，<strong>政党</strong>是由<strong>领袖</strong>来主持的</p><h2 id="第四章-资本主义的本质及规律"><a href="#第四章-资本主义的本质及规律" class="headerlink" title="第四章 资本主义的本质及规律"></a>第四章 资本主义的本质及规律</h2><h3 id="4-1-商品经济和价值规律"><a href="#4-1-商品经济和价值规律" class="headerlink" title="4.1 商品经济和价值规律"></a>4.1 商品经济和价值规律</h3><h4 id="商品的价值和使用价值（二因素）"><a href="#商品的价值和使用价值（二因素）" class="headerlink" title="商品的价值和使用价值（二因素）"></a>商品的价值和使用价值（二因素）</h4><ol><li><p>商品具有使用价值和价值两个属性</p></li><li><p><strong>使用价值</strong>是指商品能满足人们某种需要的属性，即商品的有用性，是商品的<strong>自然属性</strong>，是一切劳动产品共有的属性。</p></li><li><p><strong>价值</strong>是凝结在商品中的无差别的一般人类<strong>劳动</strong>，即<mark>人类的脑力和体力的耗费</mark>。价值是商品特有的社会属性。价值在本质上体现了生产者之间的一定社会关系。</p></li><li><p><strong>交换价值</strong>首先表现为一种使用价值同另一种使用价值交换的量的关系或比例。决定商品交换比例的是价值，而不是使用价值。<br>价值是交换价值的基础，交换价值是价值的形式。</p></li><li><p>商品的使用价值和价值之间是<strong>对立统一</strong>的关系。<br>其对立性表现在：二者不可兼得；<br>其统一性表现在：作为商品，这两者缺一不可。</p></li></ol><h4 id="劳动的二重性"><a href="#劳动的二重性" class="headerlink" title="劳动的二重性"></a>劳动的二重性</h4><ol><li><p>具体劳动：生产一定使用价值的劳动</p></li><li><p>抽象劳动：撇开一切具体形式的，无差别的一般人类劳动，即人的脑力和体力的耗费</p></li><li><p>生产商品的具体劳动创造商品的使用价值，抽象劳动形成商品的价值。劳动的二重性决定了商品的二因素。劳动的二重性是同一劳动过程中不可分割的两个方面。</p></li></ol><h4 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h4><ol><li>货币是在长期交换过程中形成的固定充当一般等价物的商品，是商品经济内在矛盾发展的产物；货币的本质体现一种社会关系</li></ol><blockquote><p>天然金银不是货币，但货币天然是金银 –马克思</p></blockquote><ol start="2"><li><p>货币的职能</p><ol><li><p>价值尺度(最基本的职能_1)</p></li><li><p>流通手段(最基本的职能_2)</p></li><li><p>贮藏手段</p></li><li><p>支付手段</p></li><li><p>世界货币</p></li></ol></li><li><p>随着货币的产生，整个商品世界分化成两级：一极是各种各样的具体商品，分别代表不同的使用价值；另一极是货币，只代表商品的价值。这样就使商品的内在使用价值和价值的矛盾发展起来，转化为商品和货币的外在矛盾</p></li></ol><hr><blockquote><p>上课补充题目–<strong>商品的价值是劳动创造的</strong><br>TRUE<br>商品的价值是劳动创造的，其实体是凝结在商品中的无差别的人类劳动，商品交换实际上是商品生产者之间相互交换劳动的关系，商品的价值在本质上体现了生产者之间的一定的社会关系。</p></blockquote><hr><blockquote><p>上课补充题目–<strong>资本主义经济危机的根源是生产过剩</strong><br>FALSE<br>资本主义经济危机的根源是资本主义社会的基本矛盾，这种基本矛盾表现在以下两个方面：<br>第一、生产无限扩大的趋势与劳动人民与支付能力的需求相对较小的矛盾。<br>第二、个别企业内即生产的有组织性和整个社会生产的无政府状态之间的矛盾。<br>生产过剩是资本主义经济危机的本质特征。生产过剩或相对过剩是资本主义社会基本矛盾活动的结果，是资本主义经济危机的诱因，而不是根本原因。  </p></blockquote><hr><h4 id="价值规律的表现形式及作用"><a href="#价值规律的表现形式及作用" class="headerlink" title="价值规律的表现形式及作用"></a>价值规律的表现形式及作用</h4><p>价值规律是商品生产和商品交换的基本规律。它的作用体现在：</p><ol><li><p>自发地调节生产资料和劳动力在社会各生产部门之间的分配比例</p></li><li><p>自发地刺激社会生产力的发展</p></li><li><p>自发地调节社会收入的分配</p></li></ol><p>价值规律在进行上述调节时也会造成一些消极后果：</p><ol><li><p>导致社会资源浪费</p></li><li><p>阻碍技术进步</p></li><li><p>导致收入两极分化</p></li></ol><h4 id="私人劳动和社会劳动"><a href="#私人劳动和社会劳动" class="headerlink" title="私人劳动和社会劳动"></a>私人劳动和社会劳动</h4><ol><li><p><mark>私人劳动和社会劳动的矛盾</mark>是<strong>商品经济的基本矛盾</strong></p></li><li><p>私有制商品经济条件下，私人劳动和社会劳动之间的矛盾是商品经济的基本矛盾，在资本主义制度下，这种矛盾进一步发展成<strong>资本主义的基本矛盾</strong>，即<strong>生产社会化和生产资料资本主义私人占有之间的矛盾</strong>，正是这一矛盾的不断运动，<strong>使资本主义制度最终被社会主义制度所代替具有了客观必然性。</strong></p></li></ol><h3 id="4-2-资本主义经济制度的本质"><a href="#4-2-资本主义经济制度的本质" class="headerlink" title="4.2 资本主义经济制度的本质"></a>4.2 资本主义经济制度的本质</h3><h4 id="资本的原始积累"><a href="#资本的原始积累" class="headerlink" title="资本的原始积累"></a>资本的原始积累</h4><p>资本原始积累，就是以暴力手段使生产者与生产资料相分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史进程。主要通过两个途径：</p><ol><li><p>暴力手段剥夺农民土地</p></li><li><p>暴力手段掠夺货币财富</p></li></ol><blockquote><p>资本来到世间，从头到脚，每个毛孔都滴着血和肮脏的东西。——马克思</p></blockquote><hr><h4 id="劳动力成为商品与货币转化为资本"><a href="#劳动力成为商品与货币转化为资本" class="headerlink" title="劳动力成为商品与货币转化为资本"></a>劳动力成为商品与货币转化为资本</h4><p>劳动力成为商品的基本条件</p><ol><li><p>劳动者在法律上是自由人，能够把自己的劳动力当做自己的商品来支配</p></li><li><p>劳动者没有任何生产资料，没有生活资料来源，因而不得不依靠出卖劳动力为生。</p></li></ol><hr><h4 id="劳动力商品的价值"><a href="#劳动力商品的价值" class="headerlink" title="劳动力商品的价值"></a>劳动力商品的价值</h4><ol><li><p>劳动力是特殊的商品，它的价值和使用价值具有不同于普通商品的特点，劳动力的<mark>价值</mark>包括三个部分：</p><ol><li><p>维持劳动者本人生存所必需的生活资料的价值</p></li><li><p>维持劳动者家属生存所必需的生活资料的价值</p></li><li><p>劳动者接受教育和训练所支出的费用</p></li></ol><p>劳动力价值的构成包含历史和道德因素，在不同国家或不同历史时期，劳动者所必须的生活资料的数量和构成是有区别的，所以劳动力价值的最低界限是由<strong>生活上不可缺少的生活资料的价值</strong>决定的。一旦劳动力价值降低到这个界限之下，劳动力就只能在萎缩的状态下维持。</p></li><li><p>劳动力商品的使用价值的特点是，它的<mark>使用价值</mark>是价值的源泉。在消费中能够创造新的价值，而且这个新的价值比劳动力本身的价值更大。所以在货币所有者购买到劳动力以后，在消费过程中，不仅能够收回他在购买这种特殊商品时支付的价值，还能得到一个增殖的价值，即剩余价值。一旦<u>货币购买的劳动力带来剩余价值</u>，<strong>货币就变成了资本。</strong></p></li></ol><h4 id="剩余价值"><a href="#剩余价值" class="headerlink" title="剩余价值"></a>剩余价值</h4><ol><li><p>资本主义生产过程是劳动过程和价值增值过程的统一</p></li><li><p>绝对剩余价值、相对剩余价值、超额剩余价值</p><p>绝对剩余价值是指在必要劳动时间不变的条件下，由于延迟工作日的长度而生产的剩余价值<br>相对剩余价值是指在工作日长度不变的条件下通过缩短必要劳动时间而相对眼虫剩余劳动时间生产的剩余价值<br>超额剩余价值是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额  </p><p>其中，超额是原因，相对是结果</p></li></ol><hr><h4 id="资本积累"><a href="#资本积累" class="headerlink" title="资本积累"></a>资本积累</h4><p><mark>把剩余价值转化为资本，或者说，剩余价值的资本化</mark>，就是<strong>资本积累</strong>。</p><p>资本家瓜分到剩余价值后，如果将其完全用于个人消费，则生产就在原有的规模上进行，这叫<strong>资本主义简单再生产</strong>。但资本主义再生产的特点是<strong>扩大再生产</strong>。资本家占有剩余价值后，不仅用于个人消费，而是将一部分转化为资本，用于购买追加的生产资料和劳动力，使生产在扩大的规模上重复进行，从而榨取更多的剩余价值。以上便是<strong>资本积累的本质</strong>。</p><p><strong>剩余价值</strong>是<strong>资本积累的源泉</strong>；<strong>资本积累</strong>是<strong>资本主义扩大再生产的源泉。</strong></p><p>资本积累不但是社会财富占有两极分化的重要原因，而且是资本主义社会失业现象产生的根源。</p><p>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利。一方面生产资料使用社会化，生产的范围从一个企业扩大到一个国家甚至全球；另一方面生产出来的产品却完全归资本家所有。这样在生产社会化和生产资料资本主义私人占有之间便产生了深刻的矛盾。随着资本积累的不断增长，这种矛盾日益加剧，<strong>资本主义终将被社会主义取代。</strong></p><p>剩余价值的分配<br>C:不变资本，以生产资料形态存在的资本，通常是用来买原材料的钱<br>V：可变资本，用来购买劳动力的那部分资本<br>m:剩余价值&#x3D;赚的钱-成本，就多出来的钱<br>剩余价值率&#x3D;m&#x2F;V<br><br>成本价格&#x3D;C+V<br>利润 r（就是m）<br>平均利润  利润率&#x3D;r&#x2F;(C+V),其中，r&#x3D;m<br>平均利润率<br>生产价格&#x3D;C+V+m<br>超额利润</p><hr><h4 id="资本主义基本矛盾"><a href="#资本主义基本矛盾" class="headerlink" title="资本主义基本矛盾"></a>资本主义基本矛盾</h4><p><mark>生产社会化和生产资料资本主义私人占有之间的矛盾，是资本主义的基本矛盾。</mark>这是生产力和生产关系的矛盾在资本主义社会的具体体现。</p><p>本应由社会中大部分劳动者共同所有的生产资料，被少数资本家私人占有；本应按照社会需要进行管理、调节和控制的严密分工的协作而社会化的生产过程，却由少数资本家为了自己的私人利益管理；共同生产的社会化产品，被资本家私人占有。资本主义越发展，科学技术，生产力，生产社会化的程度就越高，不断发展的社会生产力就越成为资本的生产力，资本、生产资料就越集中在资本家手里，资本主义基本矛盾就越尖锐。</p><ul><li><p>资本主义经济危机的周期性源于基本矛盾阶段运动</p></li><li><p>产业资本循环的三个阶段和三种职能<br><img src="https://api2.mubu.com/v3/document_image/9bcf9cff-af22-4d81-ae19-63db7a70da6b-15867716.jpg" alt="货币资本生产资本商品资本，购买生产和销售"></p></li><li><p>资本周转<br><img src="https://api2.mubu.com/v3/document_image/3140cb1c-3e57-4553-ab38-7de3b0dae46e-15867716.jpg" alt="资本周转时间"></p></li></ul><hr><h4 id="资本主义经济危机"><a href="#资本主义经济危机" class="headerlink" title="资本主义经济危机"></a>资本主义经济危机</h4><ol><li><p>资本主义经济危机的<mark>基本特征是生产过剩</mark>。但这种过剩是相对过剩，是相对劳动人民有支付能力的过剩，而不是与劳动人民实际需要的过剩。</p></li><li><p>资本主义经济危机的<mark>根本原因是资本主义的基本矛盾</mark>。主要体现在以下两个方面：</p><ol><li><p>生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾</p></li><li><p>单个企业内部生产有组织性和整个社会生产无政府状态之间的矛盾</p></li></ol></li><li><p>资本主义经济危机具有<mark>周期性</mark>。经济危机只能得到暂时缓解而不能根除资本主义基本矛盾。</p></li><li><p>经济危机的可能性是由货币作为支付手段和流通手段引起的</p></li></ol><h2 id="第五章-资本主义的发展及其趋势"><a href="#第五章-资本主义的发展及其趋势" class="headerlink" title="第五章 资本主义的发展及其趋势"></a>第五章 资本主义的发展及其趋势</h2><h3 id="5-1-垄断资本主义"><a href="#5-1-垄断资本主义" class="headerlink" title="5.1 垄断资本主义"></a>5.1 垄断资本主义</h3><ol><li><p>垄断是指少数资本主义大企业，为了获取高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵与控制。</p></li><li><p><mark>垄断产生的原因</mark>：</p><ol><li><p>极少数企业为了高额利润联合(获得高额利润)</p></li><li><p>企业规模巨大，形成对竞争的限制，也会产生垄断(形成对竞争的限制)</p></li><li><p>激烈的竞争让竞争各方两败俱伤，企业之间达成妥协，联合起来实行垄断。(避免两败俱伤)</p></li></ol></li><li><p><mark>竞争存在的原因</mark>：</p><ol><li><p>垄断没有消除产生竞争的经济条件。竞争是商品经济的一半规律。垄断产生以后，不但没有改变生产资料的资本主义私有制，而且还促进了商品经济继续发展，所以不可能消除竞争，</p></li><li><p>垄断必须通过竞争来维持。需要在竞争中处于优势地位来保持自己的垄断</p></li><li><p>社会生产是复杂多样的，任何垄断组织都不可能把所有东西都包下来</p></li></ol></li><li><p>垄断条件下的竞争的特点</p><ol><li><p>目的上：自由竞争主要是为了获得更多的利润，垄断条件下的竞争主要是为了供自己的垄断地位。</p></li><li><p>手段上：自由竞争通过改进技术，提高劳动生产率，降低产品成本等经济手段；垄断条件下的竞争还会采取一些非经济手段，让竞争更激烈。</p></li><li><p>范围上：自由竞争主要是在国内的经济市场上，垄断条件下的竞争是在国际的各个领域上，不只有经济领域。</p></li></ol><p>总之垄断条件下的竞争，规模大，时间长，手段残酷，程度激烈，破坏性大。</p></li><li><p>金融寡头<br>经济领域：“参与制”<br>国家机器的控制：“个人联合”<br>金融寡头还通过建立政策咨询机构等方式对政府的政策施加影响，并通过掌握新闻出版，广播电视，科学教育，文化体育等上层建筑的各个领域，左右国家的内政外交及社会生活</p></li><li><p>国家垄断资本主义<br>国家政权和私人垄断资本主义融合在一起的垄断资本主义<br>主要形式：五种<br>国家所有并直接经营企业，国家与私人共有、合营企业，国家通过多种形式参与私人垄断资本主义的再生产过程，宏观调节，微观控制</p></li></ol><hr><h4 id="经济全球化"><a href="#经济全球化" class="headerlink" title="经济全球化"></a>经济全球化</h4><p>经济全球化是指在生产不断发展，科技加速进步，社会分工和国际分工不断深化，生产社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国或地区的范围而相互联系、相互依赖的过程。</p><ol><li><p>经济全球化的表现</p><ol><li><p>国际分工进一步深化</p></li><li><p>贸易全球化</p></li><li><p>金融全球化</p></li><li><p>企业生产经营全球化</p></li></ol></li><li><p>经济全球化的动因</p><ol><li><p>科学技术的进步和<strong>生产力</strong>的发展为经济全球化提供了坚实的物质基础和推动力(根本原因)</p></li><li><p>跨国公司的发展为经济全球化提供了适宜的企业组织形式</p></li><li><p>各国经济体制的变革，是经济全球化的体制保障</p></li></ol></li><li><p>经济全球化的影响</p><ol><li><p>积极作用</p><ol><li><p>为发展中国家提供先进的技术和管理经验</p></li><li><p>为发展中国家提供更多就业机会</p></li><li><p>推动发展中国家国际贸易发展</p></li><li><p>促进发展中国家跨国公司发展</p></li></ol></li><li><p>负面影响</p><ol><li><p>发达国家与发展中国家在经济全球化过程中地位和收益不平等，不平衡，发达国家与发展中国家的差距进一步扩大</p></li><li><p>加剧了发展中国家资源短缺和环境恶化</p></li><li><p>一定程度上增加经济风险</p></li></ol></li></ol></li></ol><hr><blockquote><p>上课补充–<strong>试论述经济全球化的主要内容及后果</strong><br>当今经济全球化的主要内容：<br>1.生产的全球化，跨国公司越来越成为世界经济的主导力量<br>2.贸易的全球化，国际贸易迅速发展，国际贸易成为世界经济的火车头<br>3.资金的全球化，国际金融迅速发展，巨额资金在各国之间自由流动<br>经济全球化是一把双刃剑，一方面，他为发展中国家提高提供了难得的发展机遇，有利于吸收外资，弥补国内建设资金不足；有利于引进技术和设备，实现技术发展的跨越；有利于吸收外资，弥补国内建设资金不足；有利于引进技术力量和设备，实现技术发展的优势，开拓国际市场。另一方面，它也对发展中国家民族产业发展带来限制；给发展中国家带来一些不利后果，需要付出环境污染的代价；使发展中国家面临经济风险，比如主权和经济安全受到挑战。经济全球化给发达国家和发展中国家带来的是不均等，不公正的竞争机会。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>马克思主义基本原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统基础笔记</title>
    <link href="/2021/11/19/csapp/"/>
    <url>/2021/11/19/csapp/</url>
    
    <content type="html"><![CDATA[<p>属于是一个手忙脚乱的临时更新了，因为发现自己确实啥都不会了。这篇暂时会一改我别的笔记风格，不会有任何章法，仅仅是按照我不会的程度和考试的紧迫程度进行一个相对凌乱的记录。<br>比较完整的请见<a href="https://mushroom323.github.io/2021/10/29/csapp/">🍄神的csapp笔记</a></p><h1 id="第二章-信息的表示和记录"><a href="#第二章-信息的表示和记录" class="headerlink" title="第二章 信息的表示和记录"></a>第二章 信息的表示和记录</h1><h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><h3 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h3><p><em>凌乱之余好歹还是保持目录结构的完整性</em><br>IEEE浮点标准使用$V&#x3D;(-1)^s\times M\times 2^E$来表示一个数</p><ul><li><strong>符号</strong> $s$决定这个数是正数还是负数，$s&#x3D;1$就是负数，$s&#x3D;0$就是正数。</li><li><strong>尾数</strong> $M$是一个二进制小数，它的范围是$1\sim 2-\varepsilon$，或者是$0\sim 1-\varepsilon$。</li><li><strong>阶码</strong> $E$对浮点数加权，这个权是2的$E$次幂（可能是负数）。<br>将浮点数的位表示划分为三个字段，分别对这些值进行编码（注意是编码，而不是就是这些数）</li><li>一个单独的符号位$s$直接编码符号$s$。</li><li>$k$位的阶码字段编码阶码$E$。</li><li>$n$位小数字段编码尾数$M$。<br>根据$\rm exp$的值，被编码的值可以分为三种不同的情况：</li></ul><ol><li>规格化的<br><img src="https://api2.mubu.com/v3/document_image/bc77a791-5ff6-4341-bc05-0fcb48a9a494-15002533.jpg" alt="规格化的图"><br>这是最普遍的情况，即$\rm exp$的位即不全为0，也不全为1时。此时：<ul><li>$E&#x3D; {\rm exp}-Bias,Bias&#x3D;2^{k-1}-1$（单精度Bias为127，双精度为1023）</li><li>$M&#x3D;1.f_{n-1}f_{n-2}\cdots f_0$，小数点在最高有效位的左边</li></ul></li><li>非规格化的<br><img src="https://api2.mubu.com/v3/document_image/99e4148f-a387-450a-b8be-185b78f2e3bd-15002533.jpg"><ul><li>$E&#x3D;1-Bias$</li><li>$M&#x3D;0.f_{n-1}f_{n-2}\cdots f_0$</li></ul></li><li> a.<br> <img src="https://api2.mubu.com/v3/document_image/f2f4450f-6e8b-4a51-8536-bafd3620d620-15002533.jpg"><br> 两个非常大的数相乘，或者除以0，会产生$\infty$。$s&#x3D;1$表示$-\infty$，$s&#x3D;0$表示$\infty$。<br> b. <img src="https://api2.mubu.com/v3/document_image/40177575-52a0-43e0-9572-9edac50148e3-15002533.jpg"><br> 运算结果不是实数或无穷如$\sqrt{-1}$或$\infty -\infty$，表示为NAN。</li></ol><h3 id="2-4-6-C语言中的浮点数"><a href="#2-4-6-C语言中的浮点数" class="headerlink" title="2.4.6 C语言中的浮点数"></a>2.4.6 C语言中的浮点数</h3><p>从<code>int</code>转为<code>float</code>：会舍入，不会溢出<br>从<code>int</code>转为<code>double</code>：不会舍入，不会溢出<br>从<code>float</code>转为<code>int</code>：会舍入，会溢出<br>从<code>float</code>转为<code>double</code>：不会舍入，不会溢出<br>从<code>double</code>转为<code>float</code>：会舍入，会溢出<br>从<code>double</code>转为<code>int</code>：会舍入，会溢出</p><h3 id="关于大端序和小端序"><a href="#关于大端序和小端序" class="headerlink" title="关于大端序和小端序"></a>关于大端序和小端序</h3><p><img src="https://api2.mubu.com/v3/document_image/eadc3b36-ff28-44bf-8f15-7d5a96bf4243-15002533.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记</title>
    <link href="/2021/11/01/dataStructure/"/>
    <url>/2021/11/01/dataStructure/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h1><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h3 id="1-4-1-算法"><a href="#1-4-1-算法" class="headerlink" title="1.4.1 算法"></a>1.4.1 算法</h3><ul><li>一个算法具有下列5个重要特性：<ol><li><strong>有穷性</strong>，一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间（在此，有穷的概念并不是纯数学的，而是在实际上合理的，可接受的）内完成。</li><li><strong>确定性</strong>，算法中的每一条指令必须有确切的含义，读者理解时不会出现二义性。并且在任何条件下，算法只能有唯一的执行路径，即对于相同的输入只能得到相同的输出。</li><li><strong>可行性</strong>，算法中所描述的操作都是通过已实现的基本运算执行有限次来实现的。</li><li><strong>输入</strong></li><li><strong>输出</strong></li></ol></li></ul><h3 id="1-4-2-算法设计的要求"><a href="#1-4-2-算法设计的要求" class="headerlink" title="1.4.2 算法设计的要求"></a>1.4.2 算法设计的要求</h3><ul><li>通常设计一个“好”的算法应考虑以下目标：<ol><li><strong>正确性</strong>，程序对于<strong>精心选择的典型，苛刻而带有刁难性的</strong>几组输入数据能够得出满足规格说明的结果。（这句话的描述方式让我觉得非常精彩，每次读到它都觉得这本书的写作水平很高）。</li><li><strong>可读性</strong>，算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解；晦涩难懂的程序易于隐藏较多错误，难以调试和被修改。</li><li><strong>健壮性</strong>，当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li><strong>效率与低存储量需求</strong>，效率指的是算法执行的时间，存储量指的是算法执行过程中所需要的最大存储空间。</li></ol></li></ul><h3 id="1-4-3-算法效率的度量"><a href="#1-4-3-算法效率的度量" class="headerlink" title="1.4.3 算法效率的度量"></a>1.4.3 算法效率的度量</h3><ul><li><strong>时间复杂度</strong>，是什么怎么算就不多说了，离散上学期也有讲。但需要会算具体语句的<strong>频数</strong>。比如下面代码中<code>a[i,j]=1;</code>被执行了多少次。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">3</span>; i &lt; n; ++i)&#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span> * i - <span class="hljs-number">4</span>; ++j)&#123;<br>        a[i, j] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>外面的<code>for</code>说明里面的循环进行了n-3次，即里面的等差数列共有n-3项。其中第一项为<code>for(j = 0; j &lt;= 2 * 3 - 4; ++j)</code>共3次，第二项5次……所以<code>a[i,j]=1</code>共被执行了：<br>$$<br>  \frac{(3+[3+(n-3-1)\cdot 2])(n-3)}{2}&#x3D;n^2-4n+3<br>$$<br>次。 </li><li><strong>空间复杂度</strong></li></ul><h1 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h1><ul><li>单链表原地逆置（带头结点）<br>思路很简单，边缘情况稍微有些复杂，细节很多。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(LinkedList L)</span> <br>&#123; <br>    LinkedNode j = L-&gt;next, i;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (j)&#123;<br>        i = j-&gt;next;<br>        j-&gt;next = L-&gt;next;<br>        L-&gt;next = j;<br>        j = i;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure>待续……</li></ul><h1 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h1><p>待续……</p><h1 id="第5章-数组和广义表"><a href="#第5章-数组和广义表" class="headerlink" title="第5章 数组和广义表"></a>第5章 数组和广义表</h1><h2 id="5-1-数组和线性表的关系以及数组的运算"><a href="#5-1-数组和线性表的关系以及数组的运算" class="headerlink" title="5.1 数组和线性表的关系以及数组的运算"></a>5.1 数组和线性表的关系以及数组的运算</h2><ul><li>数组的特点：<ol><li>可以认为，d维数组的非边界元素具有d个直接前趋和d个直接后继</li></ol></li></ul><p>（数组当然不止这一个特点，但其他的都很明显，不在此列举）</p><h2 id="5-2-数组的顺序存储结构"><a href="#5-2-数组的顺序存储结构" class="headerlink" title="5.2 数组的顺序存储结构"></a>5.2 数组的顺序存储结构</h2><ul><li>n维数组<br><img src="https://i.loli.net/2021/11/15/uV27nWlb3N1ZMQ6.jpg" alt="F4A8194BAC16C0B2601EC5DAB7CA0ED0.jpg"><br>如果对深度学习有些了解的话，可以把n维数组理解为<a href="https://www.zhihu.com/question/23720923">张量</a>。<br>理解了n维数组的本质，再去解决<strong>给定下标计算对应地址</strong>就很简单了。</li></ul><h2 id="5-3-矩阵的压缩存储"><a href="#5-3-矩阵的压缩存储" class="headerlink" title="5.3 矩阵的压缩存储"></a>5.3 矩阵的压缩存储</h2><h3 id="5-3-1-对称矩阵"><a href="#5-3-1-对称矩阵" class="headerlink" title="5.3.1 对称矩阵"></a>5.3.1 对称矩阵</h3><p><img src="https://i.loli.net/2021/11/15/M6WxRswAdqnj7ca.jpg" alt="F216CDB5A6D1A99A7101D9F0D5D9DA57.jpg"></p><h3 id="5-3-2-三角矩阵"><a href="#5-3-2-三角矩阵" class="headerlink" title="5.3.2 三角矩阵"></a>5.3.2 三角矩阵</h3><p><img src="https://i.loli.net/2021/11/15/69isBewjxvopUHO.jpg" alt="3F519532E08565246B8710E44068C247.jpg"></p><h3 id="5-3-3-带状矩阵"><a href="#5-3-3-带状矩阵" class="headerlink" title="5.3.3 带状矩阵"></a>5.3.3 带状矩阵</h3><p><img src="https://i.loli.net/2021/11/15/UHki3JtORCQphAL.jpg" alt="4B13DF10-1A3F-4006-A499-1A47E98DB0E1.png"></p><h3 id="5-3-4-随机稀疏矩阵"><a href="#5-3-4-随机稀疏矩阵" class="headerlink" title="5.3.4 随机稀疏矩阵"></a>5.3.4 随机稀疏矩阵</h3><ul><li><p><strong>三元组表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000 <span class="hljs-comment">//设定非零元素最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    <span class="hljs-type">int</span> i, j;<br>    ElemType e;<br>&#125;Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Triple data[MAXSIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">//三元组表，data[0]未用</span><br>    <span class="hljs-type">int</span> mu, nu, tu; <span class="hljs-comment">//行数、列数、非零元个数</span><br>&#125;TSMatrix;<br></code></pre></td></tr></table></figure></li><li><p>快速转置<br><img src="https://i.loli.net/2021/11/15/s3aER8FdMuvGKkt.jpg" alt="A5FC6335CEB3FDF2669D5A45E9C8ACCA.jpg"><br>其中的num只需要遍历一次三元组表就可以得到，cpot可以通过num计算得到，所以时间复杂度是$o(n+t)$。</p></li></ul><p>接下来这两个东西稍微看一下就可</p><ul><li><p>行逻辑连接的表<br><img src="https://i.loli.net/2021/11/15/oj2zWuXMbPy4Nv6.jpg" alt="3F38980CF1792EB233EFBC6AD2A2EC05.jpg"></p></li><li><p>十字链表<br><img src="https://i.loli.net/2021/11/15/NkuT81SdHqhU7Wz.jpg" alt="D16EFD521700CD4D585D38D493374D93.jpg"></p></li></ul><h2 id="5-4-广义表"><a href="#5-4-广义表" class="headerlink" title="5.4 广义表"></a>5.4 广义表</h2><ol><li><p>广义表的相关表示方法和术语<br><img src="https://i.loli.net/2021/11/15/CVRPjf9Y3nzHeS2.jpg" alt="6B6A81B2F0E340A5C638C28AF7102903.jpg"><br>注意：表尾无论是什么东西，都要用括号括起来。如果表尾什么都没有，那也要把它括起来()；如果表尾的元素是一个空表，那也要把它括起来(())；如果表尾只有一个元素，那也要把它括起来(a)。</p></li><li><p>广义表的存储结构</p><ol><li>头尾链表</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// ATOM==0:原子；LIST==1：子表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>&#123;</span><br>    ElemTag  tag;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        AtomType  atom;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>  *<span class="hljs-title">hp</span>, *<span class="hljs-title">tp</span>;</span><br>        &#125;ptr;<br>    &#125;<br>&#125;*GList1;<br></code></pre></td></tr></table></figure><p> 结构体里面套联合再套结构体，要看懂。<br> <img src="https://i.loli.net/2021/11/15/anzZhXm5O8FtpJf.jpg" alt="7CFB8063D13743F5D06DED4E54946B5D.jpg"></p><ol start="2"><li>扩展的线性表</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// ATOM==0:原子；LIST==1：子表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>&#123;</span><br>    ElemTag  tag;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        AtomType  atom;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>  *<span class="hljs-title">hp</span>;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>  *<span class="hljs-title">tp</span>;</span><br>&#125;*GList2;<br></code></pre></td></tr></table></figure><p> 个人认为这种存储方式更符合直觉。<br> <img src="https://i.loli.net/2021/11/15/hN39cToHlMmjtQX.jpg" alt="D3E16E0DF91FFB5B9E0C85E19A0A372B.jpg"></p></li><li><p>求广义表的深度</p><ul><li><p>思路1：表的深度&#x3D;表中所有元素的深度的最大值+1</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">GListDepth</span><span class="hljs-params">(GList1 L)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!L)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//空表</span><br>    <span class="hljs-keyword">if</span> (L-&gt;tag == ATOM)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//单原子</span><br>    <span class="hljs-keyword">for</span> (max = <span class="hljs-number">0</span>, pp = L; pp; pp = pp-&gt;ptr.tp)<br>    &#123;<br>        dep = GListDepth(pp-&gt;ptr.hp);<br>        <span class="hljs-keyword">if</span> (dep &gt; max)<br>            max = dep;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-comment">//GListDepth</span><br></code></pre></td></tr></table></figure><p> 注意7-12行，是如何遍历一个头尾链表的。</p></li><li><p>思路2：表的深度&#x3D;max(表头的深度+1, 表尾的深度)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">GListDepth</span><span class="hljs-params">(GList1 L)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!L)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//空表</span><br>    <span class="hljs-keyword">if</span> (L-&gt;tag == ATOM)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//单原子</span><br>    dep1 = GListDepth(L-&gt;ptr.hp) + <span class="hljs-number">1</span>;<br>    dep2 = GListDepth(L-&gt;ptr.tp);<br>    <span class="hljs-keyword">if</span> (dep1 &gt; dep2)<br>        <span class="hljs-keyword">return</span> dep1;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> dep2;<br>&#125; <span class="hljs-comment">//GListDepth</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>复制广义表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C">Status <span class="hljs-title function_">CopyGList</span><span class="hljs-params">(GList1 &amp;T, GList1 L)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!L)<br>        T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//复制空表</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        T = (GList1)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(GLNode));<br>        <span class="hljs-keyword">if</span> (!T)<br>            <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        T-&gt;tag = L-&gt;tag;<br>        <span class="hljs-keyword">if</span> (L-&gt;tag == ATOM)<br>            T-&gt;atom = L-&gt;atom; <span class="hljs-comment">//复制单原子</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            CopyGList(T-&gt;ptr.hp, L-&gt;ptr.hp);<br>            CopyGList(T-&gt;ptr.tp, L-&gt;ptr.tp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <span class="hljs-comment">//CopyGList</span><br></code></pre></td></tr></table></figure><p>这个算法又一次体现出了递归的妙处：这个函数似乎并没有显式的写出该如何去创建一个新的子表的步骤，但这却是它自己本身要做的事情。所以在看到15，16行的时候，其实从另一个角度上明白了，一个广义表无论括号是怎么嵌套的，这都属于他的逻辑结构，只有里面有字母表示的元素才是有实际意义的。</p></li></ol><h1 id="第6章-树和二叉树"><a href="#第6章-树和二叉树" class="headerlink" title="第6章 树和二叉树"></a>第6章 树和二叉树</h1><h2 id="6-1-树的结构定义和基本操作"><a href="#6-1-树的结构定义和基本操作" class="headerlink" title="6.1 树的结构定义和基本操作"></a>6.1 树的结构定义和基本操作</h2><ul><li><strong>结点的层次</strong> 表示该结点在树中的相对位置。根为第一层，其它的结点依次下推；若某结点在第L层上，则其孩子在第L+1层上。</li><li><strong>堂兄弟</strong> 双亲在同一层的结点互为堂兄弟。</li><li><strong>树的深(高)度</strong> 树中结点的最大层次。</li><li><strong>有序树</strong> 树中各结点的子树从左至右是有次序的，不能互换。否则，称为无序树。</li><li><strong>路径长度</strong> 从树中某结点Ni出发，能够“自上而下地”通过树中结点到达结点Nj，则称Ni到Nj存在一条路径，- 路径长度等于这两个结点之间的分支数。</li><li><strong>树的路径长度</strong> 从根到每个结点的路径长度之和。</li><li><strong>森林</strong> 是m(m&gt;0)棵互不相交的树的集合。</li></ul><h2 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h2><ul><li>满二叉树和完全二叉树<br><img src="https://i.loli.net/2021/11/16/heTwUHmM5tYKlG6.jpg" alt="0122CE3A1F3616FE25A5E0A8E17D4FB4.jpg"></li><li>二叉树的性质<ol><li>二叉树的第i层上至多有$2^{i-1}$($i\geq 1$)个结点。</li><li>深度为k的二叉树至多有$2^{k-1}$个结点($k\geq 1$)。</li><li>对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0&#x3D;n_2+1$。</li><li>具有n个结点的完全二叉树的深度为 $\lfloor \log 2n\rfloor +1$。</li><li>一棵具有n个结点的完全二叉树(又称顺序二叉树)，对其结点按层从上至下(每层从左至右)进行1至n的编号，则对任一结点$i$($1\leq i\leq n$)有：<ol><li>若$i\gt 1$，则i的双亲是$\lfloor i&#x2F;2\rfloor$；若$i&#x3D;1$，则$i$是根，无双亲。</li><li>若$2i\leq n$，则i的左孩子是2i；否则，$i$无左孩子。</li><li>若$2i+1\leq n$，则i的右孩子是$2i+1$；否则，$i$无右孩子。</li></ol></li></ol></li><li>二叉树的存储结构<ul><li>顺序存储<ol><li>按照层序存储，遇到空位存0；</li><li>只存存在的节点，但是每个节点要记录它的左右孩子的索引；</li><li>只存存在的节点，但是每个节点要记录它的双亲节点的索引。</li></ol></li><li>链式存储<ol><li>二叉链表（左右孩子）</li><li>三叉链表（左右孩子，双亲）</li></ol></li></ul></li></ul><h2 id="6-3-二叉树的遍历"><a href="#6-3-二叉树的遍历" class="headerlink" title="6.3 二叉树的遍历"></a>6.3 二叉树的遍历</h2><ul><li><p>目的：非线性结构$\rightarrow$线性结构</p></li><li><p>先序遍历，中序遍历，后序遍历<br><img src="https://i.loli.net/2021/11/16/YuhN2ZesOaM84tW.jpg" alt="3B1FB7A3B106E7BA2B6CCF6E9896D490.jpg"><br>思路比较简单，主要关注思考题部分和代码实现。</p></li><li><p>思考：如何利用两种遍历序列确定一个二叉树<br>先序序列: ABCDEFGH<br>中序序列: BDCEAFHG<br>复原过程如下，务必自己动手画一遍，找一下感觉<br><img src="https://i.loli.net/2021/11/16/yD47CTqPWbrf8kj.jpg" alt="209DEC03C82CD3880E068692BE4B7C8E.jpg"></p></li><li><p>算法实现<br>下面的所有算法都要牢记于脑，内化于心，达到闭上眼睛就能有一张在二叉树上遍历的动图的程度。</p><ol><li>先序遍历<br>  递归实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">Preorder(BiTree bt)<br>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        visite(bt);<br>        Preorder(bt-&gt;lc);<br>        Preorder(bt-&gt;rc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  改进的递归算法  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">Preorder2(BiTree bt)<br>&#123;<br>    visite(bt);<br>    <span class="hljs-keyword">if</span> (bt-&gt;lc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Preorder2(bt-&gt;lc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bt-&gt;rc != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Preorder2(bt-&gt;rc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  消除尾递归的算法  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">Preorder3(BiTree bt)<br>&#123;<br>    <span class="hljs-keyword">while</span> (bt != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        visite(bt);<br>        Preorder3(bt-&gt;lc);<br>        bt = bt-&gt;rc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>非递归算法</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">Preorder4(Bitree bt)<br>&#123;<br>    inistack(s);<br>    p = bt;<br>    push(s, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        visite(p);<br>        <span class="hljs-keyword">if</span> (p-&gt;rc != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            push(s, p-&gt;rc);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;lc != <span class="hljs-literal">NULL</span>)<br>            p = p-&gt;lc;<br>        <span class="hljs-keyword">else</span><br>            p = pop(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  先在栈里铺垫一个NULL<br>  然后每次循环过来，先visit自己<br>  然后如果自己的右支不是NULL就入栈<br>  然后如果自己的左支不是NULL就变成自己的左支；如果自己的左支是NULL就变成出栈元素<br>  直到自己变成NULL。</li><li>中序遍历  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">Inorder(BiTree bt)<br>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Inorder(bt-&gt;lc);<br>        visite(bt);<br>        Inorder(bt-&gt;rc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>后序遍历  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">Postorder(BiTree bt)<br>&#123;<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Postorder(bt-&gt;lc);<br>        Postorder(bt-&gt;rc);<br>        visite(bt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>层序遍历<br>  类似广度优先搜索  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C">Levelorder(BiTreptr bt)<br>&#123;<br>    iniqueue(q);<br>    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)<br>        enqueue(q, bt);<br>    <span class="hljs-keyword">while</span> (!empty(q))<br>    &#123;<br>        t = dequeue(q);<br>        visite(t);<br>        <span class="hljs-keyword">if</span> (t-&gt;lc != <span class="hljs-literal">NULL</span>)<br>            enqueue(q, t-&gt;lc);<br>        <span class="hljs-keyword">if</span> (t-&gt;rc != <span class="hljs-literal">NULL</span>)<br>            enqueue(q, t-&gt;rc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-4-线索二叉树"><a href="#6-4-线索二叉树" class="headerlink" title="6.4 线索二叉树"></a>6.4 线索二叉树</h2><ul><li><p>通过前面介绍的二叉树可知，遍历二叉树实际上就是将树中所有结点排成一个线性序列（即非线性结构线性化）。在这样的线性序列中，很容易求得某个结点在某种遍历下的直接前趋和后继。然而，有时我们希望不进行遍历，就能很快找到某个结点在某种遍历下的直接前趋和后继。这样，就应该把每个结点的直接前趋和直接后继记录下来。</p></li><li><p>线索二叉树的存储结构<br><img src="https://i.loli.net/2021/11/16/TQ6dmfYxPpLaW5t.jpg" alt="4C48FA1CD4C00473547C71A4E30EFEF6.jpg"><br><img src="https://i.loli.net/2021/11/16/8EprLsSmIGkgtuz.jpg" alt="562C5844BA89626B95297A9CDCC5B5FC.jpg"></p></li><li><p>但有些结点的Lchild或Rchild指针域指向其左孩子或右孩子，而没有记录其前趋或后继结点信息，要找到该结点的前趋或后继，还要进行一定的搜索。例如，上图A结点的前趋是D（即A结点的左子树的最右下结点）；A结点的后继是F（即A结点的右子树的最左下结点）。那我们该怎么找一个节点的前驱或者后继呢（以中序线索树为例）？</p><ul><li>后继<ol><li>若p-&gt;rtag&#x3D;1，则p-&gt;rc即为所求；</li><li>若p-&gt;rtag&#x3D;0，则从其右子沿着左链走到ltag&#x3D;1的那个结点就是。</li></ol></li><li>前驱<ol><li>若p-&gt;ltag&#x3D;1，则p-&gt;lc即为所求；</li><li>若p-&gt;ltag&#x3D;0，则从其左子沿着右链走到rtag&#x3D;1的那个结点就是。</li></ol></li></ul></li><li><p>二叉树的中序线索化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C">pre = <span class="hljs-literal">NULL</span>;<br>inthread(BiThrNode p)<br>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        inthread(p-&gt;lc);<br>        <span class="hljs-keyword">if</span> (p-&gt;lc == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            p-&gt;ltag = <span class="hljs-number">1</span>;<br>            p-&gt;lc = pre;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (pre-&gt;rc == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                pre-&gt;rtag = <span class="hljs-number">1</span>;<br>                pre-&gt;rc = p;<br>            &#125;<br>            pre = p;<br>            inthread(p-&gt;rc);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先把自己的左支线索化<br>再把自己线索化，线索化自己的时候，看自己有没有左支，要是没有左支就和pre连起来；再看pre有没有右支，要是没有右支，就和自己连起来，然后每次更新一个都要把pre变成自己。<br>然后再线索化自己的右支。<br>其中pre是全局变量。</p></li><li><p>遍历中序线索树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">inorder_thlinked(BiThrTree bt)<br>&#123;<br>    p = bt;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> ((p-&gt;ltag == <span class="hljs-number">0</span>)&amp;&amp;(p-&gt;lc != <span class="hljs-literal">NULL</span>))<br>        &#123;<br>            p = p-&gt;lc;<br>            visite(p);<br>            <span class="hljs-keyword">while</span> ((p-&gt;rtag = <span class="hljs-number">1</span>) &amp;&amp; (p-&gt;rc != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>                p = p-&gt;rc;<br>                visite(p);<br>            &#125;<br>            p = p-&gt;rc;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要中序遍历一个树，一开始肯定先找他的最左下的结点。找到之后visit他，然后再找他的线索，有没有直接指示的后继，有指示的后继就一路visit过去，直到没有的时候，说明当前的树的左支和自己已经visit完了，可以visit它的右支了，就把自己变成自己的右支，然后visit下一轮。</p></li><li><p>在线索二叉树里更新节点<br>  自己讨论各种情况寻找一下规律即可，老师也没有讲具体的算法，以下随便举一例：<br>  在中序线索树中插入结点t，使其称为结点s的右孩子。</p><ol><li>若s无右孩子<ol><li>s的后继变成t的后继</li><li>s成为t的前驱</li><li>t成为s的右孩子</li></ol></li><li>若s有右孩子<ol><li>s的右孩子变成t的右孩子</li><li>s的右孩子的前驱变成t</li><li>t的前驱成为s</li><li>t变成s的右孩子<br>  要做几次操作，操作什么顺序，现场要想清楚。</li></ol></li></ol></li></ul><h2 id="6-5-哈夫曼树及其应用"><a href="#6-5-哈夫曼树及其应用" class="headerlink" title="6.5 哈夫曼树及其应用"></a>6.5 哈夫曼树及其应用</h2><h3 id="6-5-1-术语"><a href="#6-5-1-术语" class="headerlink" title="6.5.1 术语"></a>6.5.1 术语</h3><p><img src="https://i.loli.net/2021/11/16/awy7TSIfdPDUjX3.jpg" alt="35018878D5742301764187346F76F44F.jpg"></p><h3 id="6-5-2-建立最优二叉树的方法"><a href="#6-5-2-建立最优二叉树的方法" class="headerlink" title="6.5.2 建立最优二叉树的方法"></a>6.5.2 建立最优二叉树的方法</h3><ol><li>将给定权值从小到大排序成${w_1,w_2,\cdots,w_m}$，生成一个森林$F&#x3D;{T_1,T_2,\cdots,T_m}$，其中$T_i$是一个带权$W_i$的根结点，它的左右子树均空。</li><li>把F中根的权值最小的两棵二叉树T1和T2合并成一棵新的二叉树T：T的左子树是T1，右子树是T2，T的根的权值是T1、T2树根结点权值之和。</li><li>将T按权值大小加入F中，同时从F中删去T1和T2</li><li>重复2.和3. ，直到F中只含一棵树为止，该树即为所求。<br><img src="https://i.loli.net/2021/11/16/lO9NUXiJBcTqopn.jpg" alt="60A77ACE9A08C129D70983EEEB653890.jpg"></li></ol><h3 id="6-5-3-哈夫曼树的存储结构"><a href="#6-5-3-哈夫曼树的存储结构" class="headerlink" title="6.5.3 哈夫曼树的存储结构"></a>6.5.3 哈夫曼树的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">Const m = 结点数目；(m = <span class="hljs-number">2</span>n - <span class="hljs-number">1</span>) <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> parent, lch, rch;<br>&#125; HTNode;<br><br>Typedef HTNode HuffmanTree[m];<br><br>HuffmanTree ht;<br></code></pre></td></tr></table></figure><p>每个节点存自己的权值，左子右子和双亲。顺序存储。</p><h3 id="6-5-4-哈夫曼树的应用"><a href="#6-5-4-哈夫曼树的应用" class="headerlink" title="6.5.4 哈夫曼树的应用"></a>6.5.4 哈夫曼树的应用</h3><ul><li><p>哈夫曼编码<br><img src="https://i.loli.net/2021/11/16/XZzMBP74in5kbju.jpg" alt="E93F171F9274BDDBD41103BE83B1D53A.jpg"></p></li><li><p>哈夫曼编码的特点</p><ol><li>哈夫曼编码是不等长编码</li><li><strong>哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀</strong></li><li>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1</li><li>发送过程：根据由哈夫曼树得到的编码表送出字符数据</li><li>接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑与数字系统笔记</title>
    <link href="/2021/10/28/digitalLogicSystemMidTerm/"/>
    <url>/2021/10/28/digitalLogicSystemMidTerm/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-开关理论基础"><a href="#第一章-开关理论基础" class="headerlink" title="第一章 开关理论基础"></a>第一章 开关理论基础</h1><h2 id="1-1-二进制系统"><a href="#1-1-二进制系统" class="headerlink" title="1.1 二进制系统"></a>1.1 二进制系统</h2><h3 id="1-1-1-连续量和离散量"><a href="#1-1-1-连续量和离散量" class="headerlink" title="1.1.1 连续量和离散量"></a>1.1.1 连续量和离散量</h3><p>电子电路分为模拟电子电路和数字电子电路两大类。<br>模拟电子电路中，数值的度量采用直流电压或电流的<strong>连续</strong>值，通常称为<strong>模拟量</strong>。<br>数字电子电路中，数值的度量采用数字量，它通常由0或1组成的一串二进制数组成，数字量的特点是数值为<strong>离散量</strong>。</p><h2 id="1-2-数制与码制"><a href="#1-2-数制与码制" class="headerlink" title="1.2 数制与码制"></a>1.2 数制与码制</h2><h3 id="1-2-2-进位计数制的相互转换"><a href="#1-2-2-进位计数制的相互转换" class="headerlink" title="1.2.2 进位计数制的相互转换"></a>1.2.2 进位计数制的相互转换</h3><ul><li>10进制转其他进制（以10进制转8进制为例）<ol><li>在整数部分采用<strong>除8取余</strong>的方式进行，除得的余数是对应8进制数的<strong>倒序</strong>。<br>  <img src="https://i.loli.net/2021/10/28/6i3wo7tk1bRS5c2.jpg" alt="6F47FA20-3784-40BD-A997-34C7B8E30CB6.png"></li><li>在小数部分采用<strong>乘8取整</strong>的方式进行，乘得的整数部分是对应8进制小数的<strong>正序</strong>。<br>  <img src="https://i.loli.net/2021/10/28/evIJt2UunzxPByd.jpg" alt="5D49FC5C-3B6A-45D0-AF3D-94C8C5800C76.png"></li></ol></li><li>其他进制转10进制：按照权值相加法即可。</li><li>八进制，十六进制转二进制：一个八进制数刚好对应3位二进制数，一个十六进制刚好对应4位二进制数。</li><li>二进制转八进制，十六进制：在整数部分的头部和小数部分的尾部补0，然后按照3个或4个一组转化为相应的八进制或十六进制数。</li></ul><h3 id="1-2-3-二进制编码"><a href="#1-2-3-二进制编码" class="headerlink" title="1.2.3 二进制编码"></a>1.2.3 二进制编码</h3><ol><li>二进制码（值域：0~15）<ul><li>自然二进制码：即最正常的二进制数，按照权值进行计算。</li><li>循环码：任何相邻的两个码字（如6和7）之间，仅有一位代码不同，其他位代码相同。循环码的编码不是唯一的，4位循环码就有很多种。下图所示为比较基本的一种。<br> <img src="https://i.loli.net/2021/10/28/1HIos9gEM3rhvpm.jpg" alt="A4EF0479-EDCB-4935-8A37-E764F3E07CAA.png"></li></ul></li><li>二-十进制码（BCD码，值域：0~9）<ul><li>8421码：把0~9用自然二进制码（0000~1001）表示出来，每四位为一个10进制数。</li><li>5421码：这种编码的显著特点是最高位先连续5个1后连续5个0。</li><li>2421码：这种编码的0~4与8421码相同，特点是每位取反后刚好是对9的补码。</li><li>余3码：在8421码的基础上加上0011，特点是执行十进制数相加时能正确的产生进微信号。</li><li>格雷码：与循环码性质一样，但值域是0~9。<br> <img src="https://i.loli.net/2021/10/28/j4h5ikvVYGuZPlw.jpg" alt="83F5CA9B-0AA9-4F40-ABE0-E9F5B27E6D21.png"></li></ul></li></ol><h2 id="1-3-逻辑函数及其描述工具"><a href="#1-3-逻辑函数及其描述工具" class="headerlink" title="1.3 逻辑函数及其描述工具"></a>1.3 逻辑函数及其描述工具</h2><h3 id="1-3-4-正逻辑，负逻辑，三态门"><a href="#1-3-4-正逻辑，负逻辑，三态门" class="headerlink" title="1.3.4 正逻辑，负逻辑，三态门"></a>1.3.4 正逻辑，负逻辑，三态门</h3><ul><li>如果把门电路的输入，输出电压的高电平赋值为逻辑“1”，低电平赋值为逻辑“0”，这种关系称为<strong>正逻辑</strong>关系。反之，称为<strong>负逻辑</strong>。</li><li><strong>三态门</strong>的输入有两个：使能端和输入端；输出端有三种情况：逻辑1，逻辑0，高阻抗。当使能端有效（逻辑1）时，输出状态取决于输入端；无效（逻辑0）时，输出端呈现高阻抗状态，意味着输出与后面的电路断开。<br><img src="https://i.loli.net/2021/10/28/rmLNScvqQiDjUTH.jpg" alt="7505ED1F-FAE1-48A8-A1D7-E91F0277A147.png"></li></ul><h2 id="1-4-布尔代数"><a href="#1-4-布尔代数" class="headerlink" title="1.4 布尔代数"></a>1.4 布尔代数</h2><h3 id="1-4-1-布尔代数的基本定律"><a href="#1-4-1-布尔代数的基本定律" class="headerlink" title="1.4.1 布尔代数的基本定律"></a>1.4.1 布尔代数的基本定律</h3><p>此处只列出几条不好记的：</p><ul><li>分配律<ol><li>$A(B+C)&#x3D;AB+AC$;</li><li>$A+BC&#x3D;(A+B)(A+C)$。</li></ol></li><li>吸收率<ol><li>$A+AB&#x3D;A$;</li><li>$A(A+B)&#x3D;A$;</li><li>$A+\overline{A}B&#x3D;A+B$</li><li>$(A+B)(A+C)&#x3D;A+BC$</li></ol></li></ul><h3 id="1-4-3-用布尔代数简化逻辑函数"><a href="#1-4-3-用布尔代数简化逻辑函数" class="headerlink" title="1.4.3 用布尔代数简化逻辑函数"></a>1.4.3 用布尔代数简化逻辑函数</h3><p><strong>最简的与或表达式</strong>：乘积项的数目是最少的，在此基础上，每个乘积项中变量的个数也最少。</p><h2 id="1-5-卡诺图"><a href="#1-5-卡诺图" class="headerlink" title="1.5 卡诺图"></a>1.5 卡诺图</h2><h3 id="1-5-1-卡诺图的结构与特点"><a href="#1-5-1-卡诺图的结构与特点" class="headerlink" title="1.5.1 卡诺图的结构与特点"></a>1.5.1 卡诺图的结构与特点</h3><ol><li>逻辑函数的最小项表达式<ul><li>一个逻辑函数，如果有$n$个逻辑变量，则有$2^n$个<strong>最小项</strong>。例如，3个变量的最小项有$\overline{A}\overline{B}\overline{C},\overline{A}\overline{B}C,\cdots,ABC$。可以把他们从0~7编码分别记为$m_0,m_1,\cdots,m_7$。</li><li>任何一个逻辑函数可以化成一种典型的表达式（相当于离散数学中的主析取范式），这种典型的表达式是一组最小项之和，称为<strong>最小项表达式</strong>。</li></ul></li><li>卡诺图的结构<br><img src="https://i.loli.net/2021/10/28/KCsIEMDn9rJbe34.jpg" alt="7ABB69C9-738B-4780-B555-C05ABCD52367.png"><br><em><strong>注意</strong></em> 卡诺图的横轴和纵轴都采用循环码进行编码，不能随意调换顺序。</li><li>卡诺图的有用组合</li></ol><ul><li>在卡诺图中<strong>几何相邻</strong>的2个，4个，8个元素，也是<strong>逻辑相邻</strong>的。此外，卡诺图的第一行和最后一行，第一列和最后一列也是逻辑相邻的。</li></ul><h3 id="1-5-2-用卡诺图简化逻辑函数"><a href="#1-5-2-用卡诺图简化逻辑函数" class="headerlink" title="1.5.2 用卡诺图简化逻辑函数"></a>1.5.2 用卡诺图简化逻辑函数</h3><ol><li><p>用卡诺图简化逻辑函数的规则和步骤</p><ol><li>将逻辑函数表示在卡诺图中</li><li>识别围圈8方格的组合，如果不行进行3.。</li><li>识别围圈4方格的组合，如果不行进行4.。</li><li>识别围圈2方格的组合。</li><li>把不能和其他方格组合的一个方格单独围圈<br><img src="https://i.loli.net/2021/10/29/a3cW7i5jVRzGUsM.jpg" alt="E6E24A3F677AE7677ADA3AA1C8649B78.jpg"></li></ol></li><li><p>具有无关项的化简</p></li></ol><ul><li>无关项$\phi$是为有关项服务的，如果一个围圈里围住的全是$\phi$，这个围圈就没有意义。但即使是为了一个有意义的项，也可以为了它围住任意多的$\phi$。</li><li>在不同的围圈里，相同位置的$\phi$取值可以不同。</li></ul><h1 id="第二章-组合逻辑"><a href="#第二章-组合逻辑" class="headerlink" title="第二章 组合逻辑"></a>第二章 组合逻辑</h1><h2 id="2-1-组合逻辑分析"><a href="#2-1-组合逻辑分析" class="headerlink" title="2.1 组合逻辑分析"></a>2.1 组合逻辑分析</h2><h3 id="2-1-5-组合逻辑中的竞争冒险"><a href="#2-1-5-组合逻辑中的竞争冒险" class="headerlink" title="2.1.5 组合逻辑中的竞争冒险"></a>2.1.5 组合逻辑中的竞争冒险</h3><ul><li>在组合逻辑中，当逻辑门有两个互补输入信号同时向相反状态变化时，输出端可能会产生过渡干扰脉冲的现象称为<strong>竞争冒险</strong>。<br><img src="https://i.loli.net/2021/10/29/J8vzLpoeOarP7Ry.jpg" alt="7036F4D6B1B1218E936B43152711D841.jpg"></li><li>如图所示，$A$由0变1时，$\overline{A}$会在一个延迟后由1变0。所以存在一个短时间$A$和$\overline{A}$均为1，此时与非门输出0。但是按照逻辑分析，与非门的输出应该恒为1。</li><li>并不是所有情况下都会出现这种状况，如$A$由1变0时，即使$\overline{A}$的变化有延迟，那也不过是出现了$A$和$\overline{A}$均为0的情况，并不会影响与非门恒为1的输出。</li><li>解决方案<ol><li><strong>加选通脉冲</strong>：电路的输入发生变化时不立刻输出，在等待一段时间电路稳定后再输出。用选通脉冲$P$实现这一点，平常选通脉冲$P&#x3D;0$，要输出时$P&#x3D;1$。</li><li><strong>修改逻辑设计</strong>：通过构造一些特殊的逻辑，消除竞争冒险（比较费劲，主要是要理清逻辑关系，在稍微复杂一点的电路里面很难看出来）。但其实只要在一开始设计的时候，保证电路中各个门的输入端在信号转换时只有一个变量改变状态就可以了。</li></ol></li></ul><h2 id="2-2-组合逻辑设计"><a href="#2-2-组合逻辑设计" class="headerlink" title="2.2 组合逻辑设计"></a>2.2 组合逻辑设计</h2><ul><li>组合逻辑设计步骤：<ol><li>根据文字描述的要求列出真值表；</li><li>画出卡诺图进行化简；</li><li>写出逻辑函数表达式；</li><li>根据逻辑函数表达式，搭建组合逻辑电路图。</li></ol></li><li>与非门电路：把与或门取两次非。</li></ul><h2 id="2-4-数据选择器与分配器"><a href="#2-4-数据选择器与分配器" class="headerlink" title="2.4 数据选择器与分配器"></a>2.4 数据选择器与分配器</h2><h3 id="2-4-1-数据选择器"><a href="#2-4-1-数据选择器" class="headerlink" title="2.4.1 数据选择器"></a>2.4.1 数据选择器</h3><ul><li><strong>数据选择器</strong>是一种多路输入，单路输出的标准化逻辑构件。其输出等于哪一路输入取决于控制信号。如下图，$S_0$和$S_1$的4种真值指派分别对应输出等于$D_0$~$D_3$。<br><img src="https://i.loli.net/2021/10/29/QjrzJf8etn1TsFc.jpg" alt="4092D72C19C0CEA79F43804D7A9B8AA8.jpg"></li></ul><h3 id="2-4-2-数据分配器"><a href="#2-4-2-数据分配器" class="headerlink" title="2.4.2 数据分配器"></a>2.4.2 数据分配器</h3><ul><li><strong>数据分配器</strong>的功能与多路选择器相反，它是一种单路输入、多路输出的逻辑构件，从哪一路输出则取决于当时的地址控制端输入。如下图，$S_0$和$S_1$的4种真值指派分别对应输出的线路是$f_0$~$f_3$，不输出的线路为默认值1。<br><img src="https://i.loli.net/2021/10/29/RBYPL3kW7I4bTJ5.jpg" alt="8B05476E582E60023FFD3530630CBE8A.jpg"></li></ul><h2 id="2-5-编码器和译码器"><a href="#2-5-编码器和译码器" class="headerlink" title="2.5 编码器和译码器"></a>2.5 编码器和译码器</h2><h3 id="2-5-1-译码器"><a href="#2-5-1-译码器" class="headerlink" title="2.5.1 译码器"></a>2.5.1 译码器</h3><ul><li>实现译码功能的组合逻辑电路称为<strong>译码器</strong>，他的输入是一组二进制代码，输出是一组高低电平信号。每输入一组不同的代码，只有一个固定模式的输出组合，这个固定模式的输出组合中只有一个输出呈现有效状态。</li></ul><ol><li><p>3线-8线译码器和2线-4线译码器：<br>例：输入为101，经过3线-8线译码器译码后输出为11111011。对于101这个输入，输出一定是这样的，而且只有$\overline{Y_5}$这一个输出是有效的。<br><img src="https://i.loli.net/2021/10/29/v9I6tugNQeSHosY.jpg" alt="5D159C5FAB9382FEF570F24528E9FFA6.jpg"></p></li><li><p>七段数字译码显示系统<br>原理比较简单，如下图所示，但要注意是共阳极还是共阴极。如果是共阴极，则输出为1的二极管亮；如果是共阳极，输出为0的二极管亮。<br><img src="https://i.loli.net/2021/10/29/j8MBpigZ53X7UOl.jpg" alt="8BC59671839388F6CE1A6875B28F36C8.jpg"></p></li></ol><h3 id="2-5-2-编码器"><a href="#2-5-2-编码器" class="headerlink" title="2.5.2 编码器"></a>2.5.2 编码器</h3><ol><li>普通编码器：<br>输入是$I_1$~$I_9$中的一个（表示0~9），输出是用$D_0$~$D_3$表示的BCD码。但是如果有两个输入同时有效，输出就会混乱。</li><li>优先编码器：<br>在普通编码器的基础上进行改进，避免输出混乱。比如下图所示的8线-3线优先编码器，当$I_7$有效的时候，不再关心其他的输入，只专注于编码$I_7$。<br><img src="https://i.loli.net/2021/10/29/35TNFR8CviQKzuH.jpg" alt="A21FA3D3E210F5C3B73C238D2C32FB51.jpg"></li></ol><h2 id="2-6-数据比较器和加法器"><a href="#2-6-数据比较器和加法器" class="headerlink" title="2.6 数据比较器和加法器"></a>2.6 数据比较器和加法器</h2><h3 id="2-6-1-数据比较器"><a href="#2-6-1-数据比较器" class="headerlink" title="2.6.1 数据比较器"></a>2.6.1 数据比较器</h3><ul><li>完成比较两组二进制数码大小比较的逻辑电路，称为<strong>数据比较器</strong>。<br>以4位比较器74HC85为例，先比较高位，若高位一样，再比较低位，以此类推。原理比较简单，但有趣的是，它们可以通过级联的方式比较更多位数的二进制数，如下图所示：<br><img src="https://i.loli.net/2021/10/29/BV2ciebyhNSmtXD.jpg" alt="1904617856B511DAE693BBB6980BCF93.jpg"><br>先比较高4位，如果高4位不同，则直接输出；若高4位一样，通过级联输入判断低4位。</li></ul><h3 id="2-6-2-加法器"><a href="#2-6-2-加法器" class="headerlink" title="2.6.2 加法器"></a>2.6.2 加法器</h3><ol><li><p>串行加法器<br>由多个全加器（FA）串行连接而成。每一个FA有3个输入：加数$A_i$，被加数$B_i$，低位的进位信号$C_{i-1}$；有2个输出：和数$S_i$，向高位的进位信号$C_i$。然后就这样一个一个的把结果加出来。<br><img src="https://i.loli.net/2021/10/29/nesPgy13c8oTQCb.jpg" alt="D3026930FF467C8884B53E32D33556BB.jpg"></p></li><li><p>并行加法器<br>为了提高串行加法器的速度，一次性算出来结果。原理是通过归递推公式得到每位结果和输入之间直接的关系，不再依赖上一级的结果。<br>设$G_i$为进位生成项，$P_i$为进位传递项，即有：<br>$$<br> G_i&#x3D;A_iB_i,P_i&#x3D;A_i\oplus B_i \\<br> C_i&#x3D;G_i+P_iC_{i-1}<br>$$<br>由此递推可得：<br>$$<br> C_1&#x3D;G_1+P_1C_0 \\<br> C_2&#x3D;G_2+P_2C_1&#x3D;G_2+P_2G_1+P_2P_1C_0 \\<br> \vdots \\<br> C_4&#x3D;G_4+P_4C_3&#x3D;\cdots \\<br>$$<br>各位和的输出为<br>$$<br> S_i&#x3D;P_i\oplus C_{i-1}<br>$$<br>如此一来，便可以不用等待的，一次性的把每一位的结果直接通过输入算出来。</p></li></ol><h2 id="2-7-奇偶校验器"><a href="#2-7-奇偶校验器" class="headerlink" title="2.7 奇偶校验器"></a>2.7 奇偶校验器</h2><h3 id="2-7-1-奇偶校验器的基本原理"><a href="#2-7-1-奇偶校验器的基本原理" class="headerlink" title="2.7.1 奇偶校验器的基本原理"></a>2.7.1 奇偶校验器的基本原理</h3><p><strong>偶数个1，他们的合数总是0；奇数个1，他们的和数总是1。</strong></p><h3 id="2-7-2-具有奇偶校验的数据传输"><a href="#2-7-2-具有奇偶校验的数据传输" class="headerlink" title="2.7.2 具有奇偶校验的数据传输"></a>2.7.2 具有奇偶校验的数据传输</h3><p>把所有东西都异或一遍就行了，因为异或运算符合结合律，甚至不需要管异或的顺序。</p><h1 id="第三章-时序逻辑"><a href="#第三章-时序逻辑" class="headerlink" title="第三章 时序逻辑"></a>第三章 时序逻辑</h1><h2 id="3-1-锁存器"><a href="#3-1-锁存器" class="headerlink" title="3.1 锁存器"></a>3.1 锁存器</h2><h3 id="3-1-1-锁存器的基本特性"><a href="#3-1-1-锁存器的基本特性" class="headerlink" title="3.1.1 锁存器的基本特性"></a>3.1.1 锁存器的基本特性</h3><ul><li><p>锁存器在电路上具有两个稳定的物理状态，所以它们能记忆一位二进制数。它们具有以下特性：</p><ol><li>有两个互补的输出端$Q$和$\overline{Q}$；</li><li>有两个稳定的状态。通常将$Q&#x3D;1$和$\overline{Q}&#x3D;0$称为0状态，$Q&#x3D;0$和$\overline{Q}$称为1状态；</li><li>在输入信号的作用下，锁存器可以从一个状态转移到另一个状态。</li></ol></li><li><p>我们把输入信号发生变化之前的锁存器状态称为<strong>现态（PS）</strong>，用$Q^n$和$\overline{Q^n}$表示；输入信号发生变化之后所进入的状态称为<strong>次态（NS）</strong>，用$Q^{n+1}$和$\overline{Q^{n+1}}$表示。若用$X$来表示输入信号的集合，则有：<br>$$<br>  Q^{n+1}&#x3D;f(Q^n,X)<br>$$<br>这个方程被称为锁存器的<strong>次态方程</strong>，又称<strong>现态方程</strong>，也称为<strong>特征方程</strong>。</p></li></ul><h3 id="3-1-2-基本SR锁存器"><a href="#3-1-2-基本SR锁存器" class="headerlink" title="3.1.2 基本SR锁存器"></a>3.1.2 基本SR锁存器</h3><p><img src="https://i.loli.net/2021/10/30/fSIcMYrhOuCno6B.jpg" alt="052DCFC7088771770960D2830C0A576A.jpg"><br>如上图所示：<br>    1. 若$\overline{S}\overline{R}&#x3D;00$，两个与非门的输出均为1，也就是说$Q^{n+1}&#x3D;\overline{Q^{n+1}}&#x3D;1$，不符合互补输出的条件，此时称锁存器的状态是不稳的。在画卡诺图的时候，这一部分对应的方格就可以用$\phi$表示。<br>    2. 若$\overline{S}\overline{R}&#x3D;11$，此时锁存器将会延续它的上一个状态。比如上一个状态是1，则$Q^n&#x3D;1,\overline{Q}&#x3D;0$。此时若$\overline{S}\overline{R}&#x3D;11$，可知上面的与非门输出为1，下面的与非门输出为0，刚好与上个状态契合。根据对称性可知，这样的性质对上个状态是0的情况依然适用。<br>    3. 若$\overline{S}\overline{R}&#x3D;01$，此时先看上面的与非门因为有$\overline{S}&#x3D;0$的存在所以它一定输出1，然后下面的与非门两个输入都是1，所以输出0。此时锁存器的状态将会无条件变为1。<br>    4. 若$\overline{S}\overline{R}&#x3D;10$，与上一条同理，锁存器状态变为0。</p><p>由此可以总结出SR锁存器的状态方程：<br>$$<br>    Q^{n+1}&#x3D;\overline{\overline{S}}+\overline{R}Q^n \\<br>    \overline{S}+\overline{R}&#x3D;1<br>$$<br>SR锁存器的状态转移图如下图所示：<br><img src="https://i.loli.net/2021/10/30/epm3fxNGAbMi98q.jpg" alt="9E8B74D1-0363-4E6C-89F7-B49D4CE84662.png"></p><h3 id="3-1-3-门控SR锁存器"><a href="#3-1-3-门控SR锁存器" class="headerlink" title="3.1.3 门控SR锁存器"></a>3.1.3 门控SR锁存器</h3><p><img src="https://i.loli.net/2021/10/30/JVe5vHo8RXpMqau.jpg" alt="11C4E368-4DEA-400D-96E5-91E8A3C51FB5.png"></p><ul><li>门控SR锁存器是在普通SR锁存器的基础上改进的产物。当门控信号$EN&#x3D;1$时，锁存器会发生和普通SR锁存器一样的状态转移；当门控信号$EN&#x3D;0$时，无论$SR$为什么值，锁存器的状态都不会发生变化。</li></ul><h3 id="3-1-4-门控D锁存器"><a href="#3-1-4-门控D锁存器" class="headerlink" title="3.1.4 门控D锁存器"></a>3.1.4 门控D锁存器</h3><p><img src="https://i.loli.net/2021/10/30/s6TWw7yLY41zRvF.jpg" alt="06DFE5DF883EDC5CA5FD7D0C856DE618.jpg"></p><ul><li>门控D锁存器进一步改进了门控SR锁存器。通过把$S$和$R$换成$D$和$\overline{D}$，从根本上杜绝了两个输入全为1的情况；同时若将$EN$设置为0，锁存器将依然保留“延续上一状态”的功能。</li></ul><h2 id="3-2-触发器"><a href="#3-2-触发器" class="headerlink" title="3.2 触发器"></a>3.2 触发器</h2><ul><li>锁存器虽然可以记忆一位二进制数，但接收的输入数据是在允许使能信号$EN$的控制下进行的。若$EN$保持为1，那么锁存器的状态将会根据输入的变化立刻更改（如1变0或0变1）。但这样就没有节奏的美感，人们为了让锁存器中的状态按照同一节奏，每次在固定的时刻改变状态，推出了边沿方式工作的触发器。</li><li>触发器与锁存器不同之处在于它把原来的门控信号$EN$替换为了时钟信号$CLK$。每次只会在$CLK$的上升或下降沿的时候改变状态。下图中触发器前有小圆圈的就是在下降沿改变状态，没有小圆圈的就是在上升沿改变状态。<br><img src="https://i.loli.net/2021/10/30/riMkK6wWJAG7l53.jpg" alt="DB46003275DAE8BEB2AE4335564ACCD9.jpg"></li></ul><h3 id="3-2-1-SR触发器"><a href="#3-2-1-SR触发器" class="headerlink" title="3.2.1 SR触发器"></a>3.2.1 SR触发器</h3><p><img src="https://i.loli.net/2021/10/30/P6BIEY8qNGjzmeA.jpg" alt="1F3BF090-30E7-4A9A-B34D-DBC869E48CD2.png"><br><img src="https://i.loli.net/2021/10/30/XEuJzUwtN2yfMF9.jpg" alt="A272FB49-9B00-4FBD-A007-A5B78920746E.png"></p><ul><li>由上图可知，SR触发器的功能与门控SR锁存器区别不大。但它的电路图比门控SR锁存器有两点改变，这两点改变在从锁存器转化为触发器的工程中几乎是共性的：<ol><li>门控信号$EN$变为了$CLK$时钟信号；</li><li>时钟信号在输入时加了一个窄脉冲产生器。这个器件的作用在于把上升（下降）沿变得更“锋利”，让触发器可以更好的识别上升（下降）沿。</li></ol></li></ul><h3 id="3-2-2-D触发器"><a href="#3-2-2-D触发器" class="headerlink" title="3.2.2 D触发器"></a>3.2.2 D触发器</h3><ul><li>D触发器是SR触发器的优化版本，优化原理如同D门控锁存器之于SR门控锁存器。功能比较简单，在此不再赘述。</li></ul><h3 id="3-2-3-JK触发器"><a href="#3-2-3-JK触发器" class="headerlink" title="3.2.3 JK触发器"></a>3.2.3 JK触发器</h3><p><img src="https://i.loli.net/2021/10/30/jXRoh9drMNWCUyp.jpg" alt="71CC55A6-D1CA-4672-8AB9-E3D46338014F.png"></p><ul><li>JK触发器和SR触发器在置1，置0和保持这几个方面的功能是完全一样的，但JK触发器优化了SR触发器状态不稳的情况。现在当$JK&#x3D;11$时，无论触发器的状态目前是什么，都会变成另一个。<strong>JK触发器的特征方程非常重要：</strong><br>$$<br>  Q^{n+1}&#x3D;J\overline{Q^n}+\overline{K}Q^n<br>$$<br><em><strong>注意</strong></em>：<em>JK触发器的J输入端如果什么都没有接，默认是1；如果输入端接了很多东西，默认是他们取与运算的结果作为输入</em></li></ul><h2 id="3-3-寄存器和移位寄存器"><a href="#3-3-寄存器和移位寄存器" class="headerlink" title="3.3 寄存器和移位寄存器"></a>3.3 寄存器和移位寄存器</h2><h3 id="3-3-1-寄存器"><a href="#3-3-1-寄存器" class="headerlink" title="3.3.1 寄存器"></a>3.3.1 寄存器</h3><ul><li>课本上介绍了两种寄存器，一种由D锁存器组成，一种由D触发器组成，原理区别不大，这里仅分析D触发器组成的寄存器（74LS374）。<br><img src="https://i.loli.net/2021/10/30/c2taziWrSHjRGb1.jpg" alt="6F479198-A818-4C8B-96C3-1B40EDA2C1BC.png"><br>当输出控制是0时，寄存器会输出，输出什么取决于当前寄存器自身的状态。如果不在上升沿，则输出上次改变之后完之后的状态；如果在上升沿，那么根据当前的输入D输出改变后的状态。当输出控制是1的时候，寄存器不会输出。在寄存器不输出的时候讨论它的状态变化是没有意义的，因为D触发器的状态只与当前时刻的输入有关，与上一状态无关，如果到了某一个上升沿，输出控制变为0，此时再输出输入的D的值也是来得及的。</li></ul><h3 id="3-3-2-移位寄存器"><a href="#3-3-2-移位寄存器" class="headerlink" title="3.3.2 移位寄存器"></a>3.3.2 移位寄存器</h3><ul><li>在时钟信号的控制下，将所寄存的数据向左或向右移位的寄存器称为<strong>移位寄存器</strong>。</li><li>下图是4位右移寄存器的逻辑图。它的构成很简单，只需把左边一位的输出端接到右边一位的输入端即可，即连接关系满足$D_i&#x3D;Q_{i-1}$，同时把所有触发器的时钟端连接在一起，用同步脉冲信号控制。<br><img src="https://i.loli.net/2021/10/30/IrfoJtuLkmOhlMc.jpg" alt="9750D85B-ED2E-4271-BE9F-CF4F40B36C73.png"></li><li>但实际应用中常常采用中规模通用移位寄存器，如下图所示的74LS299:<br><img src="https://i.loli.net/2021/10/30/BFYLlmwceavAGbZ.jpg" alt="A27C2D1F-FDF6-4F62-B329-ADAE03D51586.png"><br>这个东西有四种工作模式：并行置数、左移、右移、保持数据，可以实现并入并出，并入串出，串入串出，串入并出操作。</li></ul><h2 id="3-4-计数器"><a href="#3-4-计数器" class="headerlink" title="3.4 计数器"></a>3.4 计数器</h2><p><strong>计数器</strong>的功能是记忆脉冲的个数。</p><h3 id="3-4-1-同步计数器"><a href="#3-4-1-同步计数器" class="headerlink" title="3.4.1 同步计数器"></a>3.4.1 同步计数器</h3><ul><li>同步计数器电路中，所有触发器的时钟都与同一个时钟脉冲源连在一起，每一个触发器的状态变化都与时钟脉冲同步。</li></ul><ol><li>用计数方式构成的同步计数器<ul><li>下图所示为3位同步模8计数器逻辑图：<br> <img src="https://i.loli.net/2021/10/30/Jn31ARxMj5V6fGO.jpg" alt="E5774C7D-A5DA-45BE-A6D1-BF61D9CB2FCC.png"><br> 由逻辑电路图可知，每次时钟沿到来时$J_0K_0$都为11，也就是说$FF_0$的状态每次都会改变。而$FF_1$只会在每次$Q_0$为1的时候才改变，$FF_2$则只会在$Q_0Q_1&#x3D;11$时改变。这恰好符合000，001，010…,111，000，…的顺序。</li></ul></li><li>用移位寄存器构成的同步计数器<ul><li>计数器也可以由移位寄存器构成。这时要求移位寄存器有$M$个状态，分别于$M$个计数脉冲相对应，并且不断在这$M$个状态中循环。<br> <img src="https://i.loli.net/2021/10/30/u6XlLCF2G1rkAID.jpg" alt="D47CD878-DB24-4AF5-A064-7EDAA19A58D1.png"><br> <img src="https://i.loli.net/2021/10/30/q2mV6vithX5GQzF.jpg" alt="46D6C63D-A89A-4512-BF0A-01B739F4A468.png"></li><li>若最后是$Q_2$反馈，而不是$\overline{Q_2}$反馈，那就需要一个强制端PRE或CLR设置原始状态，因为不能出现000或111。</li></ul></li></ol><h3 id="3-4-3-中规模集成计数器"><a href="#3-4-3-中规模集成计数器" class="headerlink" title="3.4.3 中规模集成计数器"></a>3.4.3 中规模集成计数器</h3><ol><li>以74LS163为例：<br><img src="https://i.loli.net/2021/10/30/csDVoOxvnytFPAb.jpg" alt="60CF1E89-DE39-4D7A-AB64-9D383BA11714.png"><br><img src="https://i.loli.net/2021/10/30/IezaRkdW27SBN3m.jpg" alt="3260775B-4D88-436B-A776-6D88C0BB8E4C.png"><br>在上升沿时，判断计数器执行什么功能：<ol><li>先看<strong>清除端</strong>，如果清除为低电平，则无论其他是什么，直接把所有触发器置0；</li><li>若清除端为高电平，再看<strong>预置端（$\overline{LD}$）</strong>，若预置端为低电平，则无论其他是什么，都把所有触发器置为预设值dcba。</li><li>若清除端为高电平，预置端也为低电平，再看<strong>使能端（$PT$）</strong>。若使能端为0，则什么都不做，若使能端为1，则计数。<br> 它的逻辑可以用一串<code>if-else</code>的嵌套描述 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// !表示低电平有效</span><br><span class="hljs-keyword">if</span> (!clear)<br>    所有触发器置<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span> (!LD)<br>        所有触发器值预设值;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(PT)<br>            计数;<br>        <span class="hljs-keyword">else</span><br>            什么都不做;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>其他的同步计数器功能类似。</li></ol><ul><li>值得一提的是，74LS163有一个进位输出，即$D_0$~$D_3$都为1时，再次进行计数，会CO会输出1。这一点可以让很多个74LS163级联成一个可以计数n位的同步计数器。</li></ul></li><li>用中规模IC计数器构成任意模数的计数器<br> 关于下列两个方法，教材上的原话说的非常好，故直接引用。<ul><li>预置法<blockquote><p>在实际构成模值为$M$的计数器时，常选用计数达到最大模值的状态为终止状态，因为这样会产生一个进位信号。利用这个进位信号（低电平有效）来作为预置控制信号$\overline{LD}。这时计数器的工作过程为：预置-计数-预置-计数……。$</p></blockquote></li><li>复位法<blockquote><p>没有预置功能的中规模计数器都有清零端，因而可通过复位法来构成任意进制计数器。其基本思想是：计数从某个状态开始，到达满足$M$的终止状态时，产生复位信号，使计数器恢复到初始状态，然后重复进行。此时需要外加门逻辑对终止状态进行检测。</p></blockquote></li></ul></li><li>用中规模IC计数器级联扩大模数<ul><li>其实只要把上一级的进位信号串入下一级就可以了，可以类比串行加法器。但精彩之处在于可以把IC计数器级联起来之后再用预置法和复位法，真正实现任意模数的计数器。</li></ul></li></ol><h2 id="3-6-同步时序逻辑分析"><a href="#3-6-同步时序逻辑分析" class="headerlink" title="3.6 同步时序逻辑分析"></a>3.6 同步时序逻辑分析</h2><h3 id="3-6-1-同步时序电路的描述工具"><a href="#3-6-1-同步时序电路的描述工具" class="headerlink" title="3.6.1 同步时序电路的描述工具"></a>3.6.1 同步时序电路的描述工具</h3><ul><li>同步时序逻辑电路按其输入与输出的关系不同，可分为<strong>米里型</strong>和<strong>摩尔型</strong>两类。当输出是输入变量和状态变量的函数，即输出（$Z$）不仅和该时刻的输入（$X_1,X_2,\cdots,X_n$）有关，而且与电路的现态（Q_1^n,Q_2^n,\cdots,Q_k^n）有关，具有这种特点的同步时序逻辑电路称为<strong>米里型</strong>时序逻辑电路（<strong>判断“101”序列</strong>）；而在<strong>摩尔型</strong>时序逻辑电路中，输出（$Z$）仅仅是状态变量的函数，而和当时的输入无关；或根本就没有$Z$输出，就以电路的状态作为输出（<strong>计数器</strong>）。</li></ul><h3 id="3-6-2-同步时序逻辑电路分析的一般方法"><a href="#3-6-2-同步时序逻辑电路分析的一般方法" class="headerlink" title="3.6.2 同步时序逻辑电路分析的一般方法"></a>3.6.2 同步时序逻辑电路分析的一般方法</h3><ul><li><p>时序逻辑电路的分析步骤一般概括如下：</p><ol><li>根据给定的逻辑图，写出输出函数和激励函数表达式（这就需要对各类触发器的特征方程非常熟悉）；</li><li>建立次态表达式及状态转移表；</li><li>建立状态表和状态转移图；</li><li>分析输出序列与输入序列的关系，说明时序逻辑电路功能。<blockquote><p>状态转移表和状态表的区别：<br><strong>状态表</strong>中的状态用$S_0,S_1,\cdots$等标识符表示，表示第几个状态，它具有一定的语义上的含义。<br><strong>状态转移表</strong>中的状态用000,001…表示，其实就是将状态表中的每一个状态都用一个二进制串表示，但此处更强调状态的逻辑含义。</p></blockquote></li></ol></li><li><p>下面挑了一道作业题作为例子，分析下图中逻辑电路的功能：<br><img src="https://i.loli.net/2021/10/31/xbYJqduRsArmHVj.jpg" alt="6D29A375-6E59-490E-8B5E-0DC083158E82.png"></p></li><li><p>先画状态转移表，再画状态转移图。中间省略了写表达式和状态表，因为电路比较简单，基本上可以通过状态转移表看出来了。<br><img src="https://i.loli.net/2021/10/31/dOvUkPAiKWGbe6I.jpg" alt="DB66B68F47AB5AA23796903DE4C59786.jpg"></p></li></ul><h3 id="3-7-同步时序逻辑设计"><a href="#3-7-同步时序逻辑设计" class="headerlink" title="3.7 同步时序逻辑设计"></a>3.7 同步时序逻辑设计</h3><h3 id="3-7-1-同步时序逻辑设计方法和步骤"><a href="#3-7-1-同步时序逻辑设计方法和步骤" class="headerlink" title="3.7.1 同步时序逻辑设计方法和步骤"></a>3.7.1 同步时序逻辑设计方法和步骤</h3><ul><li>同步时序逻辑设计步骤如下（其实就是把分析的步骤反过来）<ol><li>根据设计要求建立原始状态转移表；</li><li>对原始状态表进行简化（如果两个状态在接收相同的输入条件下输出相同，则这两个状态可以归并）；</li><li>把每个状态用一个二进制码进行编码；</li><li>由状态转移表建立最简激励函数和输出函数表达式（卡诺图），完成组合逻辑设计；</li><li>画出逻辑图。</li></ol></li></ul><h3 id="3-7-3-状态编码"><a href="#3-7-3-状态编码" class="headerlink" title="3.7.3 状态编码"></a>3.7.3 状态编码</h3><ul><li>根据对于状态编码（第3步）规则不同，可以将编码方法分为两种（以$S_0$~$S_3$）为例：</li></ul><ol><li><strong>一对一法</strong><ul><li>有4个状态，用4个触发器$Q_0$~$Q_3$。</li><li>$S_0$对应$Q_3Q_2Q_1Q_0&#x3D;0001$;</li><li>$S_1$对应$Q_3Q_2Q_1Q_0&#x3D;0010$;</li><li>$S_2$对应$Q_3Q_2Q_1Q_0&#x3D;0100$;</li><li>$S_3$对应$Q_3Q_2Q_1Q_0&#x3D;1000$;</li><li>触发器多，逻辑简单</li></ul></li><li><strong>计数器法</strong><ul><li>有4个状态，用2个触发器$Q_2Q_1$</li><li>$S_0$对应$Q_2Q_1&#x3D;00$;</li><li>$S_1$对应$Q_2Q_1&#x3D;01$;</li><li>$S_2$对应$Q_2Q_1&#x3D;10$;</li><li>$S_3$对应$Q_2Q_1&#x3D;11$;</li><li>触发器少，逻辑复杂</li></ul></li></ol><ul><li>一道作业题，设计与下图对应的电路：<br><img src="https://i.loli.net/2021/10/31/vQCu6FNqVY918JH.jpg" alt="3FE79616-822F-4F26-A459-48513F63B60A.png"><br><img src="https://i.loli.net/2021/10/31/DVvNwIBQdCM4sEZ.jpg" alt="DB031F571C50714F97FF71798D1C184B.jpg"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>数字逻辑与数字系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学（下）笔记</title>
    <link href="/2021/10/27/discreteMathMidTerm/"/>
    <url>/2021/10/27/discreteMathMidTerm/</url>
    
    <content type="html"><![CDATA[<h1 id="离散数学（下）"><a href="#离散数学（下）" class="headerlink" title="离散数学（下）"></a>离散数学（下）</h1><h2 id="离散数学及其应用-第9章-关系"><a href="#离散数学及其应用-第9章-关系" class="headerlink" title="离散数学及其应用 第9章 关系"></a>离散数学及其应用 第9章 关系</h2><h3 id="9-1-关系及其性质"><a href="#9-1-关系及其性质" class="headerlink" title="9.1 关系及其性质"></a>9.1 关系及其性质</h3><ul><li>一个从$A$到$B$的<strong>关系</strong>$R$定义为一个$A\times B$的子集。<ul><li>一个在$A$上的<strong>关系</strong>$R$就是一个$A\times A$的子集。</li></ul></li><li>自反性（reflexive）：对于任意的$a\in A$均有$(a,a)\in R$。</li><li>对称性（symmetric）：对于任意的$(a,b)\in R$均有$(b,a)\in R$。即关系矩阵中的每一个元素都<strong>必</strong>有它的对称元素。<ul><li>反对称性（antisymmetric）：对于任意的$(a,b)\in R$且$(b,a)\in R$，都有$a&#x3D;b$。即关系矩阵中每一个元素都<strong>必</strong>没有它的对称元素。</li><li>所以对于某些关系来讲，它有一部分元素有他的对称元素，有一部分元素没有它的对称元素，他就既不符合对称性也不符合反对称性。</li></ul></li><li>传递性（transitive）：对于任意的$(a,b)\in R$且$(b,c)\in R$，都有$(a,c)\in R$。</li><li>关系的复合（combination）：设$R$为一个从集合$A$到集合$B$的关系，$S$为一个从集合$B$到集合$C$的关系。则$S$和$R$关系的复合$S\circ R$是一个从集合$A$到集合$C$的关系，其中的每一个元素$(a,c)$中的$a$来自于集合$A$，$c$来自于集合$C$，且存在一个在集合$B$中的元素$b$使得$(a,b)\in R$且$(b,c)\in S$。<ul><li><em>先$R$后$S$</em></li></ul></li><li>关系的幂：$R^1&#x3D;R$，$R^{n+1}&#x3D;R^n\circ R$<ul><li><del><em>右乘</em></del></li><li><em>并不是右乘，只是用复合符号（$\circ$）时把$R$写在$R^n$的右边，代表先算$R$再算$R^n$，但实际上在进行关系矩阵的布尔积时，是左乘。即$M_{R^{n+1}}&#x3D;M_R\odot M_{R^n}$</em></li></ul></li><li>定理1：一个在集合$A$上的关系$R$具有传递性的充分必要条件是对于任意的$n&#x3D;1,2,3,\cdots$，都有$R^n \subseteq R$。</li></ul><h3 id="9-2-n-元关系"><a href="#9-2-n-元关系" class="headerlink" title="9.2 $n$元关系"></a>9.2 $n$元关系</h3><ul><li>主键（primary key）：若没有两个在关系中的$n$元组在某一个域中有同样的值，那么这个域就被称为<strong>主键</strong>。</li><li>复合键（composite key）：某若干域的组合若可以单一的确定一个在$n$元关系中的$n$元组，则这些域的笛卡尔积被称为<strong>复合键</strong>。</li></ul><h3 id="9-3-表示关系"><a href="#9-3-表示关系" class="headerlink" title="9.3 表示关系"></a>9.3 表示关系</h3><ul><li>关系矩阵<ul><li>$M_{S\circ R} &#x3D; M_R⊙M_S$</li><li>$M_{R^n} &#x3D; M_R^{[n]}$</li><li><em>先算的在左边，和关系的复合表示相反</em></li></ul></li><li>有向图<br><img src="https://api2.mubu.com/v3/document_image/1aa45386-df6d-408d-af2f-a36339b411cc-14970684.jpg"></li></ul><h3 id="9-4-关系闭包"><a href="#9-4-关系闭包" class="headerlink" title="9.4 关系闭包"></a>9.4 关系闭包</h3><ul><li>关系闭包（Closures of Relations）：设$R$是一个在集合$A$上的关系，则$R$关于性质$P$的关系闭包$S$是这样一种关系：它具有性质$P$且包含关系$R$，同时被$A\times A$中的所有具有性质$P$的关系包含着。</li><li>$R$的传递关系闭包$R^*$的关系矩阵是<br>$$<br>  M_{R^*}&#x3D;M_R\lor M_R^{[2]}\lor\cdots\lor M_R^{[n]}<br>$$<br>寻找自反关系闭包和对称关系闭包都很简单，关键在于寻找传递关系闭包。</li><li>算法1：<br><img src="https://api2.mubu.com/v3/document_image/6731e494-49d2-4b40-b4eb-3755e644059e-15002533.jpg"></li><li>Warshall算法<br>在构造$W_k$的时候，先看第$k$列哪几行是1，那么这些行就必须要包含第$k$行所包含对应位置上所有的1（同时也要包含自己本来就有的1）。<br><img src="https://api2.mubu.com/v3/document_image/16bf4e9b-6c12-4429-b1f8-f166cc62bc72-15002533.jpg"></li></ul><div id="equiv"></div><h3 id="9-5-等价关系"><a href="#9-5-等价关系" class="headerlink" title="9.5 等价关系"></a>9.5 等价关系</h3><ul><li>等价关系（equivalence relation）：若一个定义在集合$A$上的关系是自反的，<strong>对称的</strong>和传递的，那么这个关系就被称为<strong>等价关系</strong>。<br><span id="partition"></span></li><li>等价类（equivalence classes）：若$R$是一个定义在集合$A$上的关系，那么所有和$A$中元素$a$满足关系$R$的元素的集合被称为$a$的<strong>等价类</strong>。用$[a]_R$表示，若语境下只有一个关系，可以简写为$[a]$。</li><li>每一个等价关系都对应着一组等价类，这些等价关系的等价类们都可以构成集合$A$的一个划分。</li></ul><h3 id="9-6-偏序关系"><a href="#9-6-偏序关系" class="headerlink" title="9.6 偏序关系"></a>9.6 偏序关系</h3><ul><li>偏序关系（partial ordering）：若一个定义在集合$A$上的关系是自反的，<strong>反对称的</strong>和传递的，那么这个关系就被称为<strong>偏序关系</strong>。$A$中的元素被称为偏序集的元素。</li><li>若偏序集$(S,\preceq)$中的两个元素$a$和$b$满足$a\preceq b$或$b\preceq a$则称这两个元素是<strong>可比</strong>的，否则则称为不可比的。</li><li>若偏序集$(S,\preceq)$中的任意两个元素$a$和$b$都是可比的，则称$S$是一个<strong>线序集</strong>，$\preceq$是一个<strong>线序关系</strong>。</li><li>若偏序集$(S,\preceq)$是一个线序集，且每一个$S$的非空子集中都有一个最小（least）的元素则称$(S,\preceq)$是一个<strong>良序集</strong>。</li><li>哈赛图（Hasse Diagrams）：有向图省略了箭头，自反关系的圆圈，和可以由传递关系决定的关系。</li><li><strong>极大（maximal）元和极小（minimal）元</strong>：<ul><li>对于一个偏序集中的元素$a$来说，若不存在一个元素$b$使得$a\prec b$，则称$a$是这个偏序集中的一个<strong>极大元</strong>。</li><li>对于一个偏序集中的元素$a$来说，若不存在一个元素$b$使得$b\prec a$，则称$a$是这个偏序集中的一个<strong>极小元</strong>。</li><li><em>在一个偏序集中可以同时存在多个极大元和极小元</em></li></ul></li><li><strong>最大（greatest）元和最小（least）元</strong><ul><li>对于一个偏序集中的元素$a$来说，若对于任意一个元素$b$都可以使得$b\preceq a$，则称$a$是这个偏序集中的一个<strong>最大元</strong>。</li><li>对于一个偏序集中的元素$a$来说，若对于任意一个元素$b$都可以使得$a\preceq b$，则称$a$是这个偏序集中的一个<strong>最小元</strong>。</li><li><em>如果存在的话，一个偏序集中最多只有一个最大元和一个最小元</em>。</li></ul></li><li>上界（upper bound）和下界（lower bound）<ul><li>设$A$是一个偏序集$(S,\preceq)$的子集，若对于偏序集$S$中的一个元素$u$来说，任意一个$a\in A$都有$a\preceq u$，则称$u$是集合$A$的一个<strong>上界</strong>。</li><li>设$A$是一个偏序集$(S,\preceq)$的子集，若对于偏序集$S$中的一个元素$u$来说，任意一个$a\in A$都有$u\preceq a$，则称$u$是集合$A$的一个<strong>下界</strong>。</li><li>最小上界（LUB）和最大下界（GLB）<ul><li>集合$A$中所有上界中，最小的上界被称为<strong>最小上界</strong>。</li><li>集合$A$中所有下界中，最大的下界被称为<strong>最大下界</strong>。</li></ul></li></ul></li><li>格（lattice）：若在一个偏序集中，对于任意两个元素，都可以找到它们的最小上界和最大下界，则称这个偏序集为一个<strong>格</strong>。</li></ul><h2 id="离散数学结构-第9章-半群与群"><a href="#离散数学结构-第9章-半群与群" class="headerlink" title="离散数学结构 第9章 半群与群"></a>离散数学结构 第9章 半群与群</h2><h3 id="9-1-二元运算"><a href="#9-1-二元运算" class="headerlink" title="9.1 二元运算"></a>9.1 二元运算</h3><ul><li>二元运算：集合$A$上的<strong>二元运算</strong>是一个处处有定义的函数$f:A\times A\rightarrow A$。它必须满足以下性质：<ol><li>$Dom(f) &#x3D; A\times A$，即二元运算必须为$A$的每个有序元素对而定义。</li><li>因为二元运算是一个函数，所以每个有序对仅对应$A$中唯一的元素。<blockquote><p>可以定义在有$n$个元素的集合上的二元运算共有$n^{n^2}$个。</p></blockquote></li></ol></li><li>二元运算的性质<ol><li>交换性（commutative）：如果对于$A$中的所有元素有$a\ast b&#x3D;b\ast a$，则称集合$A$上的二元运算是<strong>交换</strong>的。</li><li>结合性（associative）：若对于$A$中任意的$a,b,c$都有$a\ast(b\ast c)&#x3D;(a\ast b)\ast c$，则称$A$上的二元运算是<strong>结合</strong>的。</li><li>幂等性（Idempotent）:若对于$A$中任意的$a$都有$a\ast a&#x3D;a$，则称$A$上的运算是<strong>幂等</strong>的。</li></ol></li></ul><h3 id="9-2-半群"><a href="#9-2-半群" class="headerlink" title="9.2 半群"></a>9.2 半群</h3><p>将一个集合$S$和一种运算$\ast$组合起来成为$(S, \ast)$，根据$\ast$的性质不同，可以得到以下几种不同的数学结构：</p><ol><li>广义群（groupoid）：封闭性；</li><li>半群（semigroup）：封闭性，结合性；<ul><li>单位元（identity）：在半群$(S,\ast)$中若存在这样一个元素$e$，对于所有的$a\in S$都有$e\ast a&#x3D;a\ast e&#x3D;a$，那么就称它为<strong>单位元</strong>。</li></ul></li><li>幺半群（monoid）：封闭性，结合性，具有单位元；</li><li>在以上结构的基础上，若对应的运算还满足交换性，则被称为”交换xxx“。如满足交换性的半群被称为”交换半群“。</li></ol><ul><li>自由半群（free semigroup）：从半群$(A,\cdot)$中自由地选取任意多的元素，以任意的次序进行运算，得到的所有结果的集合被称为<strong>自由半群</strong>，用$(A^\ast,\cdot)$表示。<blockquote><p>默认$\cdot$运算为字符串的拼接</p></blockquote></li><li>定理：如果$a_1,a_2,\cdots,a_n(n\geq 3)$是半群中的任意元素，那么在由元素$a_1,a_2,\cdots,a_n$形成的积中任意插入有意义的括号，积的结果都是相等的。</li><li>子半群（subsemigroup）和子幺半群（submonoid）：<ul><li>设$(S,\ast)$是一个半群，$T$是$S$的一个子集，如果$T$在运算$\ast$下是封闭的，那么称$(T,\ast)$是$(S,\ast)$的<strong>子半群</strong>。</li><li>在$(S,\ast)$是幺半群的情况下，那么在上一条的基础上再加上$e\in T$，则称$(T,\ast)$是$(S,\ast)$的<strong>子幺半群</strong>。</li></ul></li><li><strong>同构（isomorphism）和同态（Homomorphism）</strong>:<ul><li>设$(S,\ast)$和$(T,\ast &#39;)$是两个半群，如果有一个处处有定义的函数$f:S\rightarrow T$对于$S$中所有的$a$和$b$有$f(a\ast b)&#x3D;f(a)\ast &#39;f(b)$，则称$f$是从$(S,\ast)$到$(T,\ast &#39;)$的一个<strong>同态</strong>。</li><li>在此基础上，如果$f$还是一个满射，则称$T$是$S$的<strong>同态像</strong>。</li><li>在此基础上，如果$f$还是一个双射，则称$f$是从$(S,\ast)$到$(T,\ast &#39;)$的一个<strong>同构</strong>。</li></ul></li></ul><h3 id="9-3-半群的积与商"><a href="#9-3-半群的积与商" class="headerlink" title="9.3 半群的积与商"></a>9.3 半群的积与商</h3><p>本节介绍了两种从已有半群得到新半群的方法</p><ol><li>通过做积：若$(S,\ast)$和$(T,\ast&#39;)$是两个半群，则$(S\times T,\ast&#39;&#39;)$是一个半群。其中$\ast&#39;&#39;$是被等式$(s_1,t_1)\ast&#39;&#39;&#x3D;(s_1\ast s_2,t_1\ast&#39; t_2)$所定义的。<br>在介绍第二种方法前，需要先知道什么叫做同余关系。</li></ol><ul><li>同余关系（congruence relation）：一个在群$(S,\ast)$上定义的<a href="#equiv">等价关系</a>$R$，如果可以由$aRa&#39;$和$bRb&#39;$推出$(a\ast b)R(a&#39;\ast b&#39;)$，则称$R$为一个<strong>同余关系</strong>。<blockquote><p>证明同余关系的步骤：</br>1. 先证明它是一个等价关系；</br>2. 再证明可以由$aRa&#39;$和$bRb&#39;$推出$(a\ast b)R(a&#39;\ast b&#39;)$。</p></blockquote></li><li>可以从<a href="#partition">等价关系和集合划分的对应关系</a>上，定义$[a]$是包含$a$的等价类，$S&#x2F;R$表示所有等价类的集合。</li></ul><ol start="2"><li>通过做商：若$(S,\ast)$是一个半群，$R$是定义在这个半群上的一个同余关系。则$(S&#x2F;R, \circledast)$是一个半群。其中$\circledast$是被等式$[a]\circledast [b]&#x3D;[a\ast b]$所定义的。称$S&#x2F;R$为<strong>商半群</strong>。</li></ol><ul><li><p>推论：幺半群的商半群依然是幺半群。</p></li><li><p>定理：若$(S,\ast)$是一个半群，$(S&#x2F;R, \circledast)$是对应的商半群，那么由$f_R(a)&#x3D;[a]$定义的函数$f_R:S\rightarrow S&#x2F;R$是一个同态，且是满射，称其为<strong>自然同态</strong>。</p></li><li><p>定理：设$f:S\rightarrow T$是半群$(S,\ast)$到半群$(T,\ast&#39;)$的一个<strong>同态像</strong>，$R$是$S$上的关系且定义为对于$S$中的$a$和$b$，$a R b$当且仅当$f(a)&#x3D;f(b)$。那么</p><ol><li>$R$是一个同余关系。</li><li>$(T,\ast&#39;)$和商半群$(S&#x2F;R, \circledast)$是同构的。</li></ol><blockquote><p>此处经菌神确认，书上所写的”同态“并不准确，应为”同态像“。</p></blockquote></li></ul><h3 id="9-4-群"><a href="#9-4-群" class="headerlink" title="9.4 群"></a>9.4 群</h3><ul><li>群（group）：封闭性，结合性，具有单位元，每个元素都有它的逆元。</li><li>定理：设$G$是一个群，则$G$中的每个元素$a$在$G$中有且仅有一个逆元。</li><li>设$G$是一个群，则对于群中的元素$a,b,c$有以下性质<ol><li>$ab&#x3D;ac\Rightarrow b&#x3D;c$；</li><li>$ba&#x3D;ca\Rightarrow b&#x3D;c$；</li><li>对于一个函数$M_a:G\rightarrow G$满足$M_a(g)&#x3D;ag$，则$M_a$是单射；</li><li>$(a^{-1})^{-1}&#x3D;a$；</li><li>$(ab)^{-1}&#x3D;b^{-1}a^{-1}$；</li><li>方程$ax&#x3D;b$在$G$中有唯一解；</li><li>方程$ya&#x3D;b$在$G$中有唯一解。</li></ol></li><li>如果$G$是具有有限元素的一个群，则称$G$是<strong>有限群</strong>，$G$的<strong>阶</strong>是$G$中的元素个数$|G|$。</li><li>对于固定的元素标号来说1阶，2阶，3阶的群只有一个，4阶的只有两个。<blockquote><p>$Z_2\times Z_2$和$Z_4$都是4阶群，但$Z_2\times Z_2$是克莱因群，$Z_4$不是克莱因群。但4阶不同形态的群只有两个，所以所有的四阶群要么和$Z_2\times Z_2$同构，要么和$Z_4$同构。<br><strong>克莱因群</strong>：克莱因群是最小的四阶<em><strong>非</strong></em>循环群</p></blockquote></li><li><strong>群的重要例子：三角对称群</strong><br><img src="https://api2.mubu.com/v3/document_image/b2c5e487-2741-4126-aa19-75906efe108a-14970684.jpg" alt="6378A846-6533-4C01-BF91-B5B401E5A193.png"><br><img src="https://api2.mubu.com/v3/document_image/5db0d1c5-ce36-4da5-a73f-6836ea276048-14970684.jpg" alt="C22C76AF-3C6B-479C-A26F-8ED4C045B439.png"></li><li><strong>群的重要子集：子群</strong><br>设$H$是群$G$的一个子集，使得：<ol><li>$G$的单位元$e$属于$H$；</li><li>如果$a$和$b$属于$H$那么$ab\in H$；</li><li>如果$a\in H$那么$a^{-1}\in H$。<br>则称$H$是$G$的一个子群。<blockquote><p>如何寻找子群：</br>1. 先将单位元加入到集合中；</br>2. 加入一个元素，同时加入它的逆元和它本身的任意次幂；</br>3. 再加入第上一步加入的所有元素的逆元和它们的任意次幂，直到无需加入更多元素。</p></blockquote></li></ol></li><li>设$G$是一个群，则$G$和$H&#x3D;{e}$是$G$的子群，称它们为$G$的<strong>平凡子群</strong>。</li><li>定理：设$(G,\ast)$和$(G&#39;,\ast&#39;)$是两个群，$f:G\rightarrow G&#39;$是从$G$到$G&#39;$的一个同态。<ol><li>如果$e$是$G$的单位元，$e&#39;$是$G&#39;$的单位元，则$f(e)&#x3D;e&#39;$;</li><li>如果$a\in G$，则$f(a^{-1})&#x3D;(f(a))^{-1}$</li><li>如果$H$是$G$的一个子群，那么<br>$$<br>  f(H)&#x3D;\{f(h)|h\in H\}<br>$$<br>是$G&#39;$的一个子群。</li></ol></li></ul><h3 id="9-5-群的积与商"><a href="#9-5-群的积与商" class="headerlink" title="9.5 群的积与商"></a>9.5 群的积与商</h3><p>以下两种通过积和商的途径得到新群的方式与半群类似。</p><ol><li>通过做积：若$G_1$和$G_2$是群，那么$G&#x3D;G_1\times G_2$是二元运算由$(a_1,b_1)(a_2,b_2)&#x3D;(a_1a_2,b_1b_2)$定义的群。</li><li>通过做商：设$R$是群$(G,\ast)$上的一个同余关系，那么半群$(G&#x2F;R, \circledast)$是一个群，其中运算$\circledast$在$G&#x2F;R$上且满足$[a]\circledast [b]&#x3D;[a\ast b]$。</li></ol><ul><li>推论<ul><li>如果$R$是$G$上的一个同余关系，那么由$f_R(a)&#x3D;[a]$给出的函数$f_R:G\rightarrow G&#x2F;R$是群的同态。</li><li>如果$f:G\rightarrow G&#39;$$是从群(G,\ast)$到群$(G&#39;,\ast&#39;)$上的一个同态且是满射，$R$是定义在$G$上的关系，满足$a R b$当且仅当对$G$中的$a$和$b$有$f(a)&#x3D;f(b)$，那么：<ol><li>$R$是一个同余关系。</li><li>由$\overline{f}([a])&#x3D;f(a)$给出的函数$\overline{f}:G&#x2F;R\rightarrow G&#39;$是从群$(G&#x2F;R, \circledast)$到群$(G&#39;,\ast&#39;)$的一个同构且是满射。</li></ol></li></ul></li><li>左&#x2F;右陪集（left&#x2F;right coset）和正规（normal）子群：设群$H$是群$G$的一个子群，$a\in G$，由$a$决定的$G$中$H$的<strong>左陪集</strong>是集合$aH&#x3D;\{ah|h\in H\}$，<strong>右陪集</strong>是$Ha&#x3D;\{ha|h\in H\}$。最后如果对$G$中所有的$a$有$aH&#x3D;Ha$，则称$G$的子群$H$是<strong>正规子群</strong>。<blockquote><p>如何寻找正规子群：</p><ol><li>先将单位元加入到集合中；</li><li>加入一个元素，同时加入它的逆元和它本身的任意次幂；</li><li>再加入第上一步加入的所有元素的逆元和它们的任意次幂，直到无需加入更多元素。<br>（前三步就是在寻找子群，在此再重述一遍）</li><li>判断找到的这个子群$H$是否满足对于任意的$a\in G$都有$aH&#x3D;Ha$。</li></ol></blockquote></li><li><em><strong>警告</strong></em> 如果$Ha&#x3D;aH$，由此并不能得到：对于$h\in H$和$a\in G$，有$ha&#x3D;ah$，而只能得到$ha&#x3D;ah&#39;$，其中$h&#39;$是$H$中的某个元素。</li><li>若$H$是$G$的一个子群，在计算$H$的所有左&#x2F;右陪集时，当$a\in H$时不需要计算$aH$或$Ha$，因为$aH&#x3D;Ha&#x3D;H$。这一结论在书上384页有非常精彩的证明，在此不再赘述。（<a href="https://mushroom323.github.io/2021/10/29/Discrete%20mathematics/#proof">🍄神的博客里有相关的证明</a>）</li><li>定理：设$R$是群$G$上的一个同余关系，$H&#x3D;[e]$，即包含单位元的等价类，那么$H$是$G$的一个正规子群，并且对每个$a\in G$，$[a]&#x3D;aH&#x3D;Ha$。<br>由这条定理可以看到在这种情况下商群$G&#x2F;R$是由$N&#x3D;[e]$的所有左陪集所构成的，$G&#x2F;R$中的运算由<br>$$<br>  (aN)(bN)&#x3D;[a]\circledast [b]&#x3D;[ab]&#x3D;abN<br>$$<br>给出。正因如此，常把$G&#x2F;R$写成$G&#x2F;N$。</li><li>定理：设$N$是群$G$的一个正规子群，$R$是$G$的下述关系：$a R b$当且仅当$a^{-1}b\in N$。那么：<ol><li>$R$是$G$上的同余关系；</li><li>$N$是关于$R$的等价类$[e]$，其中$e$是$G$的单位元。</li></ol></li><li>核（kernel）：设$f$是从群$(G,\ast)$到群$(G&#39;,\ast&#39;)$上的同态并且是满射，$f$的<strong>核</strong>记作$\ker(f)$，定义为：<br>$$<br>  \ker(f)&#x3D;\{a\in G|f(a)&#x3D;e&#39;\}<br>$$<br>那么</li></ul><ol><li>$\ker(f)$是$G$的一个正规子群；</li><li>商群$G&#x2F;ker(f)$与$G&#39;$是同构的。</li></ol><h2 id="第11章-群与编码"><a href="#第11章-群与编码" class="headerlink" title="第11章 群与编码"></a>第11章 群与编码</h2><h3 id="11-1-二元信息码与检错码"><a href="#11-1-二元信息码与检错码" class="headerlink" title="11.1 二元信息码与检错码"></a>11.1 二元信息码与检错码</h3><ul><li>先定义一个集合$B&#x3D;\{0,1\}$，那么集合$B$在模二加法的运算下是一个群。</li><li>那么$B^m&#x3D;B\times B\times\cdots\times B$（m个因子）在$\oplus$运算（按位异或）下是一个群。他有以下特点：<ul><li>单位元是$\overline{0}&#x3D;00\cdots 0$；</li><li>每个元素都是自身的逆元；</li><li>阶（元素数量）为$2^m$</li></ul></li><li>信息传输的基本任务是减小收到的字不同于发送的字的可能性，采用以下方法可以做到这一点。首先选取一个整数$n&gt;m$和单射函数$e:B^m\rightarrow B^n$。函数$e$称为一个$(m,n)$<strong>编码函数</strong>，并且可以把它看做是$B^m$中的每个字表示成$B^n$中的一个字的一种方法。如果$b\in B^m$，那么$e(b)$称作表示b的代码字。附加的01能够提供一种方法检测或纠正在传输通道中所产生的错误。</li><li>注意到$e$是单射，所以$B^m$中的每个字将被指定为不同的代码字。</li><li>设被发送码字$b\in B^m$，代码字$x&#x3D;e(b)\in B^n$，接收字$x_t\in B^n$</li><li>一般地，传输中总是会有错误发生。如果$x$和$x_t$中至少有一个但不超过k个位置不同，则称代码字$x&#x3D;e(b)$有k个或更少的错误传送</li><li>若每当$x&#x3D;e(b)$有$k$个或更少的错误被传送时，则$x_t$不是一个代码字，则说$e$<strong>检测</strong>到k个或更少的错误。</li><li>对于$x\in B^n$，$x$中1的个数称作$x$的权，并用$|x|$表示。</li><li><strong>奇偶校验码</strong> 若$|b|$为偶数，则在最后补0；若$|b|$为奇数，则在最后补1。如此便形成了一个编码函数$e:B^m\rightarrow B^{m+1}$，最后一位称为奇偶校验码。很明显，这种编码只能检测到1个错误，对于所有的$|x_t|$为偶数的情况无能为力，不过尽管如此，奇偶校验码还是被广泛的使用。</li><li><strong>Hamming距离</strong> $x$与$y$之间的Hamming距离$\delta(x,y)&#x3D;|x\oplus y|$，使用Hamming距离计算两个二进制串$x$和$y$之间不同位的个数非常方便。</li><li>Hamming距离的性质<ul><li>$\delta(x,y)\leq\delta(x,z)+\delta(z,y)$<br>  <em>Hamming距离的性质当然不止这一条，只不过别的都是显然的，在此只说这一条</em></li></ul></li><li><strong>定理</strong>：一个$(m,n)$编码函数$e:B^m\rightarrow B^n$能够检测$k$个或更少错误当且仅当它的最短距离至少是$k+1$。<ul><li>一般的来说，要计算这个最短距离，需要把所有的$B^n$都列出来，然后两两计算距离，找出最短距离。最差情况要做$C_{2^m}^2$次计算，非常折磨。</li></ul></li></ul><hr><p><strong>但</strong></p><ul><li>确实意识到，本章到了目前为止都还没有用到一个非常好的东西，就是$(B^n,\oplus)$是一个群这一事实。下面将考虑利用$B^n$的这个性质的编码函数。</li><li><strong>群码</strong> 一个$(m,n)$编码函数$e:B^m\rightarrow B^n$称为一个<strong>群码</strong>，若<br>$$<br>  e(B^m)&#x3D;\{e(b)|b\in B^m\}&#x3D;{\rm Ran}(e)<br>$$<br>是$B^n$的一个子群。<blockquote><p>如何检验一个编码函数（N）是否是群码</p><ol><li>$00\cdots 0$在$N$中</li><li>若$x$和$y$属于$N$，则$x\oplus y\in N$。<br><strong>定理</strong>：设$e:B^m\rightarrow B^n$是一个群码，那么$e$的最短距离是非0代码字的最小权。</li></ol></blockquote></li><li>根据这条定理可以发现，算群码的最短距离是非常简单的，只需要把所有非0码字的权算出来就可以了。但确定一个编码是不是群码却要费和之前基本等同的功夫（计算步骤2需要$C_{2^m}^2$次计算）。所以我们就在想：可不可以构造一套方法，使我们只要按照这种固定的方法得到的编码就一定是群码，从而省去检查一个编码是否是群码的过程。为了介绍这种方法，我们需要先定义两种布尔矩阵的运算。</li></ul><ol><li>设$D&#x3D;[d_{ij}]$，$E&#x3D;[e_{ij}]$，则由$D\oplus E&#x3D;F$定义的$F&#x3D;[f_{ij}]$有$f_{ij}&#x3D;d_{ij}\oplus e_{ij}$。<ul><li>对应位置取异或</li></ul></li><li>设$D&#x3D;[d_{ij}]$是一个$m\times n$布尔矩阵，$E&#x3D;[e_{ij}]$是一个$n\times p$布尔矩阵，则由$D*E&#x3D;F$定义的$F&#x3D;[f_{ij}]$有<br>$$<br> f_{ij}&#x3D;d_{i1}e_{1j}+d_{i2}e_{2j}+\cdots +d_{ip}e_{pj}<br>$$<ul><li>相应行列有多少个1在相同位置，若为奇数个则为1，偶数个则为0</li><li><strong>注意</strong>：与矩阵的布尔积（$\odot$）相区分<br><strong>定理</strong>：<br>$$<br>(D\oplus E)*F&#x3D;D*F\oplus E*F<br>$$<br>现在把元素$x&#x3D;x_1x_2\cdots x_n$看成是$1\times n$矩阵。<br><strong>定理</strong>：设$m$和$n$是非负整数且$m&lt;n,r&#x3D;n-m,H$是一个$n\times r$布尔矩阵，那么函数$f_H:B^n\rightarrow B^r$定义为<br>$$<br> f_H(x)&#x3D;x*H<br>$$</li></ul></li></ol><p>是群$B^n$到$B^r$的一个同态。</p><ul><li>推论：在这种情况下<br>$$<br>N&#x3D;\{x\in B^n|x*H&#x3D;\overline{0}\}<br>$$<br>是$B^n$的一个正规子群。原因可见9.5末尾。</li></ul><p>下面开始考虑这样一个布尔矩阵<br><img src="https://api2.mubu.com/v3/document_image/6b45d213-3706-457f-874b-9bc6842aa2e9-15002533.jpg"><br>这是一个$n\times r$布尔矩阵，它的最后$r$行形成了一个$r\times r$单位矩阵，称$H$为<strong>奇偶校验矩阵</strong>。<br>下面用$H$定义一个编码函数$e_H:B^m\rightarrow B^n$，若$b&#x3D;b_1b_2\cdots b_m$，那么设$x&#x3D;e_H(b)&#x3D;b_1b_2\cdots b_mx_1x_2\cdots x_r$，其中$x_1x_2\cdots x_r$就是$b$和$H$的前$m$行做$*$运算得到的。<br><strong>定理</strong>：设$x&#x3D;y_1y_2\cdots y_mx_1x_2\cdots x_r\in B^n$，那么$x*H&#x3D;\overline{0}$仅对某个$b\in B^m,x&#x3D;e_H(b)$。</p><ul><li><strong>推论</strong>：$e_H(B^m)&#x3D;\{e_H(b)|b\in B^m\}$是$B^n$的一个子群。<br>至此，我们终于得到了一种可以稳定构造群码的方法，即：构造一个奇偶校验矩阵，用$B^m$中的每一个元素乘以它的前m行，得到的$B^r$拼接在他的后面，便是一套群码。并且通过这样的方法得到的$B^n* H$一定等于$\overline{0}$。</li></ul><h3 id="11-2-译码与纠错"><a href="#11-2-译码与纠错" class="headerlink" title="11.2 译码与纠错"></a>11.2 译码与纠错</h3><h2 id="在上一节，我们很好的利用群码已经解决了作为发送方该如何编码的问题，本节解决接收方如何译码的问题。译码函数：一个满射函数-d-B-n-rightarrow-B-m-称作是与-e-有关的译码函数，若-d-x-t-x3D-b’-in-B-m-使得当传输通道没有任何噪声时，-b’-x3D-b-。-注意到课本原文强调-d-是一个满射函数，而同时没有讲他不是一个单射函数。事实上-d-必不是一个单射函数，他的定义域需要覆盖-B-n-中所有的元素，因为一定有许多不同的-B-n-对应同一个-B-m-。设-e-是一个-m-n-编码函数，-d-是一个与-e-相关的-n-m-译码函数。如果无论-x-x3D-e-b-正确的传输或产生了-k-个或-k-个以下的错误并接收到的是-x-t-，都有-d-x-t-x3D-b-，则称数据对-e-b-可以矫正-k-个或更少的错误。"><a href="#在上一节，我们很好的利用群码已经解决了作为发送方该如何编码的问题，本节解决接收方如何译码的问题。译码函数：一个满射函数-d-B-n-rightarrow-B-m-称作是与-e-有关的译码函数，若-d-x-t-x3D-b’-in-B-m-使得当传输通道没有任何噪声时，-b’-x3D-b-。-注意到课本原文强调-d-是一个满射函数，而同时没有讲他不是一个单射函数。事实上-d-必不是一个单射函数，他的定义域需要覆盖-B-n-中所有的元素，因为一定有许多不同的-B-n-对应同一个-B-m-。设-e-是一个-m-n-编码函数，-d-是一个与-e-相关的-n-m-译码函数。如果无论-x-x3D-e-b-正确的传输或产生了-k-个或-k-个以下的错误并接收到的是-x-t-，都有-d-x-t-x3D-b-，则称数据对-e-b-可以矫正-k-个或更少的错误。" class="headerlink" title="在上一节，我们很好的利用群码已经解决了作为发送方该如何编码的问题，本节解决接收方如何译码的问题。译码函数：一个满射函数$d:B^n\rightarrow B^m$称作是与$e$有关的译码函数，若$d(x_t)&#x3D;b’\in B^m$使得当传输通道没有任何噪声时，$b’&#x3D;b$。- 注意到课本原文强调$d$是一个满射函数，而同时没有讲他不是一个单射函数。事实上$d$必不是一个单射函数，他的定义域需要覆盖$B^n$中所有的元素，因为一定有许多不同的$B^n$对应同一个$B^m$。设$e$是一个$(m,n)$编码函数，$d$是一个与$e$相关的$(n,m)$译码函数。如果无论$x&#x3D;e(b)$正确的传输或产生了$k$个或$k$个以下的错误并接收到的是$x_t$，都有$d(x_t)&#x3D;b$，则称数据对$(e,b)$可以矫正$k$个或更少的错误。"></a>在上一节，我们很好的利用群码已经解决了作为发送方该如何编码的问题，本节解决接收方如何译码的问题。<br><strong>译码函数</strong>：一个满射函数$d:B^n\rightarrow B^m$称作是与$e$有关的译码函数，若$d(x_t)&#x3D;b’\in B^m$使得当传输通道没有任何噪声时，$b’&#x3D;b$。<br>- 注意到课本原文强调$d$是一个满射函数，而同时没有讲他不是一个单射函数。事实上$d$必不是一个单射函数，他的定义域需要覆盖$B^n$中所有的元素，因为一定有许多不同的$B^n$对应同一个$B^m$。<br>设$e$是一个$(m,n)$编码函数，$d$是一个与$e$相关的$(n,m)$译码函数。如果无论$x&#x3D;e(b)$正确的传输或产生了$k$个或$k$个以下的错误并接收到的是$x_t$，都有$d(x_t)&#x3D;b$，则称数据对$(e,b)$可以<strong>矫正$k$个或更少的错误</strong>。</h2><h2 id="下面开始介绍一种可以通过编码函数-e-得到相应的译码函数-d-的方法，被称为最大似然方法。因为-B-m-有-2-m-个元素，所以-B-n-中也有-2-m-个元素与之对应，我们先把这-2-m-个元素按照某种次序排列。-x-1-x-2-cdots-x-2-m-如果接收到的字是-x-t-，那么对于-1-leq-i-leq-2-m-，计算-delta-x-i-x-t-并且选取第一个代码字，譬如说-x-s-使得-rm-min-1-leq-i-leq-2-m-delta-x-i-x-t-x3D-delta-x-s-x-t-即：-x-s-是按照当前次序中第一个和-x-t-最接近的码字。所以根据一开始排列顺序的不同，会得到不同的译码规则。定理：假设-e-是一个-m-n-编码函数，-d-是与-e-相关的最大似然译码函数，那么-e-d-能纠正-k-个或更少的错误，当且仅当-e-的距离至少是-2k-1-。定理：如果-K-是群-G-的一个有限子群，那么-G-中-K-每一个左陪集与-K-恰好有同样多的元素。"><a href="#下面开始介绍一种可以通过编码函数-e-得到相应的译码函数-d-的方法，被称为最大似然方法。因为-B-m-有-2-m-个元素，所以-B-n-中也有-2-m-个元素与之对应，我们先把这-2-m-个元素按照某种次序排列。-x-1-x-2-cdots-x-2-m-如果接收到的字是-x-t-，那么对于-1-leq-i-leq-2-m-，计算-delta-x-i-x-t-并且选取第一个代码字，譬如说-x-s-使得-rm-min-1-leq-i-leq-2-m-delta-x-i-x-t-x3D-delta-x-s-x-t-即：-x-s-是按照当前次序中第一个和-x-t-最接近的码字。所以根据一开始排列顺序的不同，会得到不同的译码规则。定理：假设-e-是一个-m-n-编码函数，-d-是与-e-相关的最大似然译码函数，那么-e-d-能纠正-k-个或更少的错误，当且仅当-e-的距离至少是-2k-1-。定理：如果-K-是群-G-的一个有限子群，那么-G-中-K-每一个左陪集与-K-恰好有同样多的元素。" class="headerlink" title="下面开始介绍一种可以通过编码函数$e$得到相应的译码函数$d$的方法，被称为最大似然方法。因为$B^m$有$2^m$个元素，所以$B^n$中也有$2^m$个元素与之对应，我们先把这$2^m$个元素按照某种次序排列。$$    x^{(1)},x^{(2)},\cdots,x^{(2^m)}$$如果接收到的字是$x_t$，那么对于$1\leq i\leq 2^m$，计算$\delta (x^{(i)},x_t)$并且选取第一个代码字，譬如说$x^{(s)}$使得$$    {\rm{min}}_{1\leq i\leq 2^m}\{\delta(x^{(i)},x_t)\}&#x3D;\delta(x^{(s)},x_t)$$即：$x^{(s)}$是按照当前次序中第一个和$x_t$最接近的码字。所以根据一开始排列顺序的不同，会得到不同的译码规则。定理：假设$e$是一个$(m,n)$编码函数，$d$是与$e$相关的最大似然译码函数，那么$(e,d)$能纠正$k$个或更少的错误，当且仅当$e$的距离至少是$2k+1$。定理：如果$K$是群$G$的一个有限子群，那么$G$中$K$每一个左陪集与$K$恰好有同样多的元素。"></a>下面开始介绍一种可以通过编码函数$e$得到相应的译码函数$d$的方法，被称为<strong>最大似然方法</strong>。<br>因为$B^m$有$2^m$个元素，所以$B^n$中也有$2^m$个元素与之对应，我们先把这$2^m$个元素按照某种次序排列。<br>$$<br>    x^{(1)},x^{(2)},\cdots,x^{(2^m)}<br>$$<br>如果接收到的字是$x_t$，那么对于$1\leq i\leq 2^m$，计算$\delta (x^{(i)},x_t)$并且选取第一个代码字，譬如说$x^{(s)}$使得<br>$$<br>    {\rm{min}}_{1\leq i\leq 2^m}\{\delta(x^{(i)},x_t)\}&#x3D;\delta(x^{(s)},x_t)<br>$$<br>即：$x^{(s)}$是按照当前次序中第一个和$x_t$最接近的码字。<br><em>所以根据一开始排列顺序的不同，会得到不同的译码规则</em>。<br><strong>定理</strong>：假设$e$是一个$(m,n)$编码函数，$d$是与$e$相关的最大似然译码函数，那么$(e,d)$能纠正$k$个或更少的错误，当且仅当$e$的距离至少是$2k+1$。<br><strong>定理</strong>：如果$K$是群$G$的一个有限子群，那么$G$中$K$每一个左陪集与$K$恰好有同样多的元素。</h2><p>下面开始关注$e$是一个$(m,n)$编码函数，且是一个群码的情况，设它的代码字集合$N$是$B^n$的一个子群，$N&#x3D;\{x^{(1)},x^{(2)},\cdots,x^{(2^m)}\}$。<br>假设代码字$x&#x3D;e(b)$接收到的字是$x_t$。$N$由$x_t$确定的左陪集是：<br>$$<br>    x_t\oplus N&#x3D;\{\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_{2^m}\}<br>$$<br>从代码字$x_t$到$x^{(i)}$的距离恰好就是$|\varepsilon_i|$，因此若$\varepsilon_j$是有最小权的陪集成员，那么$x^{(j)}$一定是距离$x_t$最近的码字。在这种情况下$x^{(j)}&#x3D;x_t\oplus \varepsilon_j$。一个有最小权的陪集元素$\varepsilon_j$被称为<strong>陪集首部</strong>。注意，由于排列次序的不同，一个陪集的首部不一定是唯一的。<br>如果$e:B^m\rightarrow B^n$是一个群码，那么下面就是得到$e$的最大似然译码函数的步骤：</p><ol><li>确定$B^n$中$N&#x3D;e(B^m)$的所有左陪集。</li><li>对于每个陪集求陪集首部。</li><li>如果收到字$x_t$，那么确定$x_t$属于$N$的陪集。</li><li>设$\varepsilon$是3.确定的陪集首部，计算$x_t\oplus \varepsilon$，那么$x_t$的译码就是$x_t\oplus \varepsilon$的译码。</li></ol><h2 id="由上述步骤1-2-确定的译码表如下所示：译码表中每一行都是一个陪集，共有-2-r-个；每一行的第一个元素都是这个陪集的陪集首部。在译码的时候只需要译-x-t-对应列首的元素即可。至此，已经得出了译一般群码的通用方法。"><a href="#由上述步骤1-2-确定的译码表如下所示：译码表中每一行都是一个陪集，共有-2-r-个；每一行的第一个元素都是这个陪集的陪集首部。在译码的时候只需要译-x-t-对应列首的元素即可。至此，已经得出了译一般群码的通用方法。" class="headerlink" title="由上述步骤1.2.确定的译码表如下所示：译码表中每一行都是一个陪集，共有$2^r$个；每一行的第一个元素都是这个陪集的陪集首部。在译码的时候只需要译$x_t$对应列首的元素即可。至此，已经得出了译一般群码的通用方法。"></a>由上述步骤1.2.确定的<strong>译码表</strong>如下所示：<br><img src="https://api2.mubu.com/v3/document_image/01253bc9-200a-42d7-9584-aeebb352fd8e-15002533.jpg"><br>译码表中每一行都是一个陪集，共有$2^r$个；每一行的第一个元素都是这个陪集的陪集首部。<br>在译码的时候只需要译$x_t$对应列首的元素即可。<br>至此，已经得出了译一般群码的通用方法。</h2><p>下面介绍由特定的奇偶校验矩阵$H$确定的群码的译码方法。<br>由函数$f_H(x)&#x3D;x*H$定义的函数$f_H:B^n\rightarrow B^r$是$B^n$到$B^r$的一个同态。<br><strong>定理</strong>：由上述定义的函数同时是一个满射。<br>元素$x*H$称为$x$的<strong>校验子</strong>。<br><strong>定理</strong>：设$x$和$y$是$B^n$中的元素，他们两个属于同一个左陪集的充分必要条件是$f_H(x)&#x3D;f_H(y)$，即二者的校验子相同。<br>所以确定这种特殊的群码的译码函数的步骤如下：</p><ol><li>确定$B^n$中$N&#x3D;e_H(B^m)$的所有左陪集。</li><li>对于每个陪集，求出陪集首部和他的校验子。</li><li>如果收到字$x_t$计算$x_t$的校验子，并且找到和$x_t$具有相同校验子的陪集首部$\varepsilon$，那么$x_t\oplus \varepsilon&#x3D;x$是代码字$e_H(b)$，所以$d(x_t)&#x3D;b$。</li></ol><h2 id="离散数学及其运用-第八章-高级计数基础"><a href="#离散数学及其运用-第八章-高级计数基础" class="headerlink" title="离散数学及其运用 第八章 高级计数基础"></a>离散数学及其运用 第八章 高级计数基础</h2><h3 id="8-1-递推关系的应用"><a href="#8-1-递推关系的应用" class="headerlink" title="8.1 递推关系的应用"></a>8.1 递推关系的应用</h3><ul><li>斐波那契数</li><li>汉诺塔问题</li><li>二进制串问题：给出一个长度为n且没有两个连续的0的二进制串的递推关系并给出初始条件</li></ul><blockquote><p>解：<br>长度为$n$且结尾是1的这样的二进制串，等于长度为$n-1$的这样的二进制串最后再加一个1。<br>长度为$n$且结尾是0的这样的二进制串，等于长度为$n-2$的这样的二进制串最后再加10。（可以仔细思考一下这之间的充分必要关系）<br>所以：$a_n&#x3D;a_{n-1}+a_{n-2}$<br>其中$a_1&#x3D;2$（0，1），$a_2&#x3D;3$（01，10，11）</p></blockquote><h3 id="8-2-求解线性递推关系"><a href="#8-2-求解线性递推关系" class="headerlink" title="8.2 求解线性递推关系"></a>8.2 求解线性递推关系</h3><ul><li><strong>定义1</strong> 一个常系数的$k$阶线性齐次递推关系是形如<br>$$<br>  a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k}<br>$$<br>的递推关系，其中$c_1,c_2,\cdots,c_k$是实数，$c_k\neq 0$</li></ul><h4 id="8-2-2-求解递推关系"><a href="#8-2-2-求解递推关系" class="headerlink" title="8.2.2 求解递推关系"></a>8.2.2 求解递推关系</h4><p>求解递推关系就是直接把$a_n$显式的写成$a_n&#x3D;f(n)$的形式，就算解出来了。</p><ul><li><p><strong>定理1</strong> 设$c_1$和$c_2$是实数。假设$r^2-c_1r-c_2&#x3D;0$有两个<strong>不相等</strong>的根$r_1$和$r_2$，那么序列$\lbrace a_n\rbrace$是递推关系$a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}$的解，当且仅当$a_n&#x3D;\alpha_1r_1^n+\alpha_2r^n_2$</p><ul><li>其中$\alpha_1$和$\alpha_2$是以下方程的解：<br>  $$<br>  a_0&#x3D;\alpha_1+\alpha_2\\<br>  a_1&#x3D;\alpha_1r_1+\alpha_2r_2<br>  $$</li></ul></li><li><p><strong>定理2</strong> 设$c_1$和$c_2$是实数。假设$r^2-c_1r-c_2&#x3D;0$有两个<strong>相等</strong>的根$r_0$，那么序列$\lbrace a_n\rbrace$是递推关系$a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}$的解，当且仅当$a_n&#x3D;\alpha_1r_0^n+\alpha_2nr^n_0$</p></li><li><p><strong>定理3</strong> 设$c_1,c_2,\cdots,c_n$是实数。假设特征方程<br>$$<br>  r^k-c_1r^{k-1}-\cdots-c_k&#x3D;0<br>$$<br>有$k$个不相等的根$r_1,r_2,\cdots,r_k$。那么序列$\lbrace a_n\rbrace$是递推关系<br>$$<br>  a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k}<br>$$<br>的解，当且仅当<br>$$<br>  a_n&#x3D;\alpha_1r^n_1+\alpha_2r^n_2+\cdots+\alpha_kr^n_k<br>$$</p></li><li><p><strong>定理4</strong> 设$c_1,c_2,\cdots,c_n$是实数。假设特征方程<br>$$<br>  r^k-c_1r^{k-1}-\cdots-c_k&#x3D;0<br>$$<br>有$t$个不相等的根$r_1,r_2,\cdots,r_t$，其重数分别为$m_1,m_2,\cdots,m_t(m_1+m_2+\cdots+m_t&#x3D;k)$。那么序列$\lbrace a_n\rbrace$是递推关系<br>$$<br>  a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k}<br>$$<br>的解，当且仅当<br>$$<br>  a_n&#x3D; (\alpha_1+\alpha_1n+\cdots+\alpha_{m_1-1}n^{m_1-1})r_1^n\\<br>  + (\alpha_2+\alpha_2n+\cdots+\alpha_{m_2-1}n^{m_2-1})r_2^n\\<br>  + \cdots+(\alpha_t+\alpha_tn+\cdots+\alpha_{m_t-1}n^{m_t-1})r_t^n<br>$$</p></li></ul><h4 id="8-2-3-求解常系数线性非齐次递推关系"><a href="#8-2-3-求解常系数线性非齐次递推关系" class="headerlink" title="8.2.3 求解常系数线性非齐次递推关系"></a>8.2.3 求解常系数线性非齐次递推关系</h4><ul><li><strong>定理5</strong> 如果$\lbrace a_n^{(p)}\rbrace$是常系数非齐次线性递推关系<br>$$<br>  a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k}+F(n)<br>$$<br>的一个特解，那么每个解都是$\lbrace a_n^{(p)}+a_n^{(h)}\rbrace$的形式，其中$\lbrace a_n^{(h)}\rbrace$是相伴的齐次递推关系<br>$$<br>  a_n&#x3D;c_1a_{n-1}+c_2a_{n-2}+\cdots+c_ka_{n-k}<br>$$<br>的一个解。</li><li>如果$F(n)$是一次多项式，那么对于$\lbrace a_n^{(p)}\rbrace$的一个合理尝试是：$\lbrace a_n^{(p)}\rbrace&#x3D;cn+d$。</li><li>如果$F(n)$是一个形如$q^n$（其中q为常数）的式子，那么对于$\lbrace a_n^{(p)}\rbrace$的一个合理尝试是：$\lbrace a_n^{(p)}\rbrace&#x3D;C\cdot q^n$。</li></ul><h3 id="8-3-分治算法和递推关系"><a href="#8-3-分治算法和递推关系" class="headerlink" title="8.3 分治算法和递推关系"></a>8.3 分治算法和递推关系</h3><p>不考</p><h3 id="8-4-生成函数"><a href="#8-4-生成函数" class="headerlink" title="8.4 生成函数"></a>8.4 生成函数</h3><ul><li><strong>定义1</strong> 实数序列$a_0,a_1,\cdots,a_k,\cdots$的生成函数是无穷级数<br>$$<br>  G(x)&#x3D;a_0+a_1x+\cdots+a_kx^k+\cdots&#x3D;\sum_{k&#x3D;0}^\infty a_kx^k<br>$$</li><li>二项式系数当上面的数是负数时<br>$$<br>\binom{-n}{r}&#x3D;(-1)^rC(n+r-1, r)<br>$$<br>书上有一张表，叫做《有用的生成函数》，其实也不用看，记住泰勒公式就行了（虽然👴🏻也没记住，👴🏻就确实是废物）。</li></ul><h2 id="第10章-图"><a href="#第10章-图" class="headerlink" title="第10章 图"></a>第10章 图</h2><h3 id="10-1-图和图模型"><a href="#10-1-图和图模型" class="headerlink" title="10.1 图和图模型"></a>10.1 图和图模型</h3><ul><li>👴🏻找不到英文版书了，就先用这个凑活着，上考场看不懂就寄</li></ul><p><img src="https://api2.mubu.com/v3/document_image/5e6990bc-3e19-45f8-8fc5-e4ae9f4054d3-15002533.jpg" alt="图模型"></p><p>👴🏻找到了<br><img src="https://api2.mubu.com/v3/document_image/0164c984-c670-486a-a597-8e118de10c1d-15002533.jpg" alt="图模型英语"></p><h3 id="10-2-图的术语已经几种特殊的图"><a href="#10-2-图的术语已经几种特殊的图" class="headerlink" title="10.2 图的术语已经几种特殊的图"></a>10.2 图的术语已经几种特殊的图</h3><ul><li><strong>定理1 握手定理</strong> 设$G&#x3D;(V,E)$是有$m$条边的无向图，则<br>$$<br>  2m&#x3D;\sum_{v\in V}deg(v)<br>$$</li><li><strong>定理2</strong> 无向图中有偶数个度为奇数的顶点。</li><li>完全图$K_n$<br><img src="https://api2.mubu.com/v3/document_image/953823a8-63da-48a4-9d62-9a9c1dcae96d-15002533.jpg" alt="完全图"></li><li>圈图$C_n$<br><img src="https://api2.mubu.com/v3/document_image/d69bfe7a-7f01-4801-8da4-9bbbca0c6515-15002533.jpg" alt="圈图"></li><li>轮图$W_n$<br><img src="https://api2.mubu.com/v3/document_image/a6013c3c-47a9-4be8-ae76-22cca90d33f1-15002533.jpg" alt="轮图"></li><li>n立方体图$Q_n$<br><img src="https://api2.mubu.com/v3/document_image/ed5a75d2-ada6-47df-9ee6-248c5efbdb22-15002533.jpg" alt="n立方体图"></li><li>二分图，完全二分图$K_{m,n}$<ul><li><strong>定理5 霍尔婚姻定理</strong> 带有二部划分$(V_1,V_2)$的二分图$G&#x3D;(V,E)$中有一个从$V_1$到$V_2$的完全匹配，当且仅当对于$V_1$的所有子集$A$，有$|N(A)|\geq |A|$。</li><li>看不懂就算了，先看别的最后回来再看这个</li></ul></li></ul><h3 id="10-2-图的表示和图的同构"><a href="#10-2-图的表示和图的同构" class="headerlink" title="10.2 图的表示和图的同构"></a>10.2 图的表示和图的同构</h3><ol><li>图的邻接矩阵：行和列都是顶点</li><li>图的关联矩阵：行是顶点，列是边</li></ol><ul><li><strong>图的同构</strong> $a$和$b$相邻当且仅当$f(a)$和$f(b)$相邻。</li><li>判断图的同构<ol><li>先判断顶点数，边数，顶点的度是否相等</li><li>判断两个图的邻接矩阵，但邻接矩阵不同也不能说明两个图不同构，只能说明找的$f$不同构</li></ol></li></ul><blockquote><p>判断图是否同构的充分必要条件尚未找到，只有这一堆必要条件和充分条件。若两个图满足很多的必要条件（也就是说他们看上去真的很像是同构的），但依然不是同构的，则称为<strong>魔鬼对</strong>。这个名字就很有意思。</p></blockquote><h3 id="10-4-连通性"><a href="#10-4-连通性" class="headerlink" title="10.4 连通性"></a>10.4 连通性</h3><ol><li>无向图的连通性<br><strong>定义3</strong> 若无向图中每一对顶点之间都有通路，则称该图是连通的。</li><li>有向图的连通性<br><strong>定义4</strong> 若有向图中每一对顶点之间都有通路，则称该图是<strong>强连通</strong>的。<br><strong>定义5</strong> 若有向图所对应的无向图中每一对顶点之间都有通路，则称该图是<strong>弱连通</strong>的。</li><li>有向图的强连通分支<br>有向图$G$的子图是强连通的，但又不包含在任何其他更大的$G$的强连通子图中，则可称为$G$的强连通分支。</li></ol><p>两个图同时存在长度为$k$的通路是两个图同构的必要条件</p><h3 id="10-5-欧拉通路和哈密顿通路"><a href="#10-5-欧拉通路和哈密顿通路" class="headerlink" title="10.5 欧拉通路和哈密顿通路"></a>10.5 欧拉通路和哈密顿通路</h3><ol><li>欧拉通路<ul><li><strong>定理1</strong> 含有至少两个顶点的连通多重图具有欧拉回路的充分必要条件是每个顶点的度都为偶数。</li><li><strong>定理2</strong> 含有至少两个顶点的连通多重图具有欧拉通路但不具有欧拉回路的充分必要条件是恰有两个顶点的度为奇数。</li></ul></li><li>哈密顿通路<br>目前还没有找到关于哈密顿通路的充分必要条件，但是找到了很多充分条件，这些充分条件都是本着一个朴素的想法产生的：一个图的边越多，越容易有哈密顿回路。<ul><li><strong>定理3 狄拉克定理</strong> 在一个有$n$个顶点的简单图中（$n\geq 3$），若每个顶点的度都大于$n&#x2F;2$则该图有哈密顿回路</li><li><strong>定理4 欧尔定理</strong> 在一个有$n$个顶点的简单图中（$n\geq 3$），若每一对不相邻的顶点之间都有$deg(u)+deg(v)\geq n$，则该图有哈密顿回路。</li></ul></li></ol><h3 id="10-6-最短通路"><a href="#10-6-最短通路" class="headerlink" title="10.6 最短通路"></a>10.6 最短通路</h3><ol><li>Dijkstra</li><li>邻接矩阵（Floyd）算法</li></ol><blockquote><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">https://blog.csdn.net/qq_35644234/article/details/60870719</a></p></blockquote><h3 id="10-7-平面图"><a href="#10-7-平面图" class="headerlink" title="10.7 平面图"></a>10.7 平面图</h3><p><strong>定理1 欧拉公式</strong> 一个有$e$条边，$v$个顶点的平面图，将整个平面划分成$e-v+2$个面。<br><strong>定理2</strong> 一个图不是平面图当且仅当它包含一个$K_{3,3}$或$K_5$的同胚。</p><h3 id="10-8-图着色"><a href="#10-8-图着色" class="headerlink" title="10.8 图着色"></a>10.8 图着色</h3><p><strong>定理1 四色定理</strong> 平面图的着色数不超过4。</p><ul><li>着色多项式 <del>不会，等神教我</del> 会了，看<a href="http://sarlren.top/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%9B%BE%E8%AE%BA/#10-8-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98">神的博客</a></li></ul><h3 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h3><p>看书，不理解也没关系，就生搬硬套。</p><p><em>感谢菌，飞，以及平时诸多向我提出问题让我意识到自己的错误的同学对此篇笔记做出的贡献。</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>学校课程</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十届全国大学生数学竞赛初赛（非数学类）</title>
    <link href="/2021/10/22/mathCom10/"/>
    <url>/2021/10/22/mathCom10/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2OTE2NzczNQ==&mid=2649993594&idx=2&sn=a69cddb36ad9cc1c9534dc0dcc0a8bc4&chksm=f2e36c62c594e5745855eec1cc519506ed65561e20ee35ab178095c18751e87ffd414a912353&scene=21#wechat_redirect">试卷链接</a></p><h1 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>使用倒变换。</p><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>$$<br>\lim_{x\rightarrow 0}[(1+x)^n-1] \sim nx<br>$$</p><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><ul><li>柯西不等式<br>$$<br>\left[\int f(x)g(x)dx \right]^2 \leq \int f(x)dx\int g(x)dx \\<br>ab \leq \frac{(a+b)^2}{4}<br>$$</li></ul><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><ul><li>坐标轴变换<br>$$<br>(x-a)^2+(y-b)^2+(z-c)^2 &#x3D; r^2<br>$$<br>可换为：<br>$$<br>x&#x3D;r\sin\varphi\cos\theta+a,y&#x3D;r\sin\varphi\sin\theta+b,z&#x3D;r\cos\varphi+c<br>$$</li><li>三重积分也可以分段积分</li></ul><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><p>梯度的定义+拉格朗日中值定理</p><h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><ul><li>积分的级数表示形式<br>$$<br>\int_0^1f(x)dx&#x3D;\lim_{n\rightarrow +\infty}\frac{1}{n}\sum_{k&#x3D;1}^nf(x_k),\ x_k\in[\frac{k-1}{n},\frac{k}{n}]<br>$$</li></ul><h1 id="所有题目："><a href="#所有题目：" class="headerlink" title="所有题目："></a>所有题目：</h1><p><img src="https://i.loli.net/2021/10/22/CrIXg5zOcd21qT3.png" alt="IMG_0658.PNG"><br><img src="https://i.loli.net/2021/10/22/oPMAmhapHV7CTv9.png" alt="IMG_0659.PNG"><br><img src="https://i.loli.net/2021/10/22/tkWynZYmL2pcADf.png" alt="IMG_0660.PNG"><br><img src="https://i.loli.net/2021/10/22/WodZqwJp19KTlvL.png" alt="IMG_0661.PNG"><br><img src="https://i.loli.net/2021/10/22/XBImC6dcaE4kfYg.png" alt="IMG_0662.PNG"><br><img src="https://i.loli.net/2021/10/22/vdF8leBszwE6buD.png" alt="IMG_0663.PNG"><br><img src="https://i.loli.net/2021/10/22/NYx1XwDMnOU9uQa.png" alt="IMG_0664.PNG"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九届全国大学生数学竞赛初赛（非数学类）</title>
    <link href="/2021/10/19/mathCom9/"/>
    <url>/2021/10/19/mathCom9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2OTE2NzczNQ==&mid=2649993579&idx=3&sn=c0d6dd4e25eb1d698c6ca52424f6ea4c&chksm=f2e36c73c594e56534e1d171f3d4e9e790dc1252e08e572b41422b888e6eba6b247871ed35f2&scene=21#wechat_redirect">试卷链接</a></p><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><ul><li><strong>正定矩阵</strong><br>  若一个实对称矩阵$A$，对于任何的非零向量$X$都有$X^TAX&gt;0$，则称该矩阵为正定矩阵。</li></ul><h1 id="所有题目："><a href="#所有题目：" class="headerlink" title="所有题目："></a>所有题目：</h1><p><img src="https://i.loli.net/2021/10/19/7eQHk3DOSIhyp5L.png" alt="IMG_0652.PNG"><br><img src="https://i.loli.net/2021/10/19/ko6RYw4q87VGSbT.png" alt="IMG_0653.PNG"><br><img src="https://i.loli.net/2021/10/19/Q2oPyVt1c4bTBkH.png" alt="IMG_0654.PNG"><br><img src="https://i.loli.net/2021/10/19/bd6eTjMHD5zvplw.png" alt="IMG_0655.PNG"><br><img src="https://i.loli.net/2021/10/19/9A1rlkgJdDavq6t.png" alt="IMG_0656.PNG"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Electron中使用IPC广播实现主进程和渲染进程的通信</title>
    <link href="/2021/10/18/ipc/"/>
    <url>/2021/10/18/ipc/</url>
    
    <content type="html"><![CDATA[<ul><li>要实现一个主页面和子页面来回跳转的功能，试图使用<code>mainWindow.loadFIle()</code>来加载子页面。但是这是主进程才能进行的操作，于是需要在渲染进程里当需要跳转的时候就广播出一个信号，当主进程监听到这个信号，就开始<code>loadFile()</code>。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ol><li>在主进程中和渲染进程中加入<code>ipcMain</code>和<code>ipcRenderer</code>。<ul><li>在<code>main.js</code>中 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;ipcMain&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>在<code>index.js</code>和<code>dataset.js</code>中 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;ipcRenderer&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>在渲染进程中定义每次返回，跳转时需要发出信号的函数。<ul><li>在<code>index.js</code>中 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newPage</span>(<span class="hljs-params"></span>)&#123;<br>    ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;openDatasetPage&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在<code>dataset.js</code>中 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">backToMain</span>(<span class="hljs-params"></span>)&#123;<br>    ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;comeBackToMain&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>在主进程中定义接收到信号之后的行为。<ul><li>在<code>main.js</code>中 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;openDatasetPage&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    mainWindow.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;./dataset.html&#x27;</span>);<br>&#125;)<br><br>ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;comeBackToMain&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    mainWindow.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;./index.html&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li>在HTML文件中把按钮和功能联系起来。<ul><li>在<code>index.html</code>中 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;more&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;showWindow()&quot;</span>&gt;</span><br>更多...<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在<code>dataset.html</code>中 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;backToMain()&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;backButton&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/返回.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;backImage&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八届全国大学生数学竞赛初赛（非数学类）</title>
    <link href="/2021/10/15/mathCom8/"/>
    <url>/2021/10/15/mathCom8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2OTE2NzczNQ==&mid=2649993462&idx=2&sn=03a0580c0eaf8690448776ad544db1f1&chksm=f2e36deec594e4f83742ba95b482db5e2322e48031e7920fdc5b1fce34d7e225172bbb881999&scene=21#wechat_redirect">试卷链接</a><br>因为好不容易有一套自己会做的稍微多一点的题，发出来纪念一下。</p><h1 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a>一、填空题</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>导数的定义。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>导数的定义。</p><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>$$<br>y’+P(x)y&#x3D;Q(x) \\<br>y &#x3D; e^{-\int P(x)dx}(\int Q(x)e^{\int P(x)dx}dx+C)<br>$$</p><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>$$<br>f^{(n)}(0)&#x3D;A\cdot n!<br>$$<br>其中$A$是$f(x)$的麦克劳林展开式中$x^n$项的系数。</p><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p>想不起来曲面切平面怎么求可以拿平面试一下。</p><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><p>一直求导直到做出来为止，高中难度。</p><h1 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h1><p>换元把椭球换成球。三重积分的换元公式：<br>$$<br>M &#x3D; \iiint (x^2+y^2+z^2)dxdydz&#x3D;\iiint F(u,v,w)\left|\frac{\partial(x,y,z)}{\partial(u,v,w)}\right|dudvdw<br>$$<br>$$<br>\left|\frac{\partial(x,y,z)}{\partial(u,v,w)}\right|&#x3D;\left|<br>\begin{array}{cccc}<br>    \frac{\partial x}{\partial u}  &amp;  \frac{\partial x}{\partial v}   &amp; \frac{\partial x}{\partial w} \\<br>    \frac{\partial y}{\partial u}  &amp;  \frac{\partial y}{\partial v}   &amp; \frac{\partial y}{\partial w} \\<br>    \frac{\partial z}{\partial u}  &amp;  \frac{\partial z}{\partial v}   &amp; \frac{\partial z}{\partial w} \\<br>\end{array}<br>\right|<br>$$<br>换元之后注意利用对称性。</p><h1 id="第四题，第五题"><a href="#第四题，第五题" class="headerlink" title="第四题，第五题"></a>第四题，第五题</h1><p><img src="https://i.loli.net/2021/10/15/KuAqNtgxXWdfIGS.png" alt="IMG_0626.PNG"><br><img src="https://i.loli.net/2021/10/15/MbgfIRrwtyj2Uxv.png" alt="IMG_0627.PNG"><br><img src="https://i.loli.net/2021/10/15/GuAFNvBLy3qTmeO.png" alt="IMG_0628.PNG"><br>过于巧妙，感觉自己能做到的只有记住傅立叶级数。</p><ul><li>傅里叶级数<br>$$<br>f(x) &#x3D; \frac{a_0}{2}+\sum_{n&#x3D;1}^{\infty}[a_n\cos\frac{2\pi n}{T}x+b_n\sin\frac{2\pi n}{T}x] \\<br>a_n &#x3D; \frac{2}{T}\int_{t_0}^{t_0+T}f(x)\cos\frac{2\pi n}{T}xdx \\<br>b_n &#x3D; \frac{2}{T}\int_{t_0}^{t_0+T}f(x)\sin\frac{2\pi n}{T}xdx<br>$$</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客遇到的坑</title>
    <link href="/2021/10/10/holesInBlog/"/>
    <url>/2021/10/10/holesInBlog/</url>
    
    <content type="html"><![CDATA[<h1 id="部署博客时没有样式"><a href="#部署博客时没有样式" class="headerlink" title="部署博客时没有样式"></a>部署博客时没有样式</h1><ul><li>如下设置<code>_config.yml</code>:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://heyewuyue1.github.io</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/heyewuyue1/heyewuyue1.github.io</span><br><br></code></pre></td></tr></table></figure></li></ul><h1 id="Series点进去没有反应"><a href="#Series点进去没有反应" class="headerlink" title="Series点进去没有反应"></a>Series点进去没有反应</h1><ul><li>直接把<code>themes/vexo/layout/series.ejs</code>删除就可以了。也不知道series是干嘛的，删了之后点series就是一个空白的md页面。至少不会卡死了，就这样吧。</li></ul><h1 id="博客里面插入不了图片"><a href="#博客里面插入不了图片" class="headerlink" title="博客里面插入不了图片"></a>博客里面插入不了图片</h1><ul><li><del>尚未解决</del>。</li><li>用<a href="http://sm.ms/">图床</a>解决了。官方文档一点都不好使，感觉几年没更新了。</li><li>发现其实白嫖<a href="https://mubu.com/app">幕布</a>的图床更爽一些</li></ul><h1 id="博客的多行公式不能用-换行"><a href="#博客的多行公式不能用-换行" class="headerlink" title="博客的多行公式不能用\\换行"></a>博客的多行公式不能用\\换行</h1><ul><li>后来发现原来在渲染的时候“\\”会被渲染成“\”。所以要实现多行公式的换行要在源文件里输入四个“\”也就是“\\\\”。这样渲染完才是两个“\”。（包括我打这段话的时候每个“\”，都要输入双倍的“\”）</li></ul><h1 id="博客的评论不好使"><a href="#博客的评论不好使" class="headerlink" title="博客的评论不好使"></a>博客的评论不好使</h1><ul><li>vexo主题自带的评论系统因为种种原因要不就是不好使，要不就是根本用不了。我现在采用的是valine评论系统，直接采用暴力的方法把valine的html和js源码复制在每篇md下方即可。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/valine/dist/Valine.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;vcomments&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Valine</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#vcomments&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">appId</span>: <span class="hljs-string">&#x27;appId&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">appKey</span>: <span class="hljs-string">&#x27;appKey&#x27;</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>搭建博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
